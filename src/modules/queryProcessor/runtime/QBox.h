#ifndef QBOX_H
#define QBOX_H

#include <vector>
#include <deque>
#include <sstream>

#include "Exceptions.h"
#include "TupleQueue.h"
#include <nmstl_util.h>
#include "TupleDescription.h"
#include "Stream.h"
#include "BoxStatsSample.h"
#include "PtMutex.h"
#include "LockHolder.h"
#include "Scheduler.h"
#include "LockSet.h"
#include "Tuple.h"

#include "xercesDomFwd.h"
#include <sys/time.h>

#include "QBoxState.h"

#include <fstream>

BOREALIS_NAMESPACE_BEGIN

class AuroraNode;
class Table;
class QBoxInvocation;
class SweeperQBox;
class CPQBox;
class HAUnit;


////////////////////////////////////////////////////////////////////////////////
///
/// A box in the catalog.  QBox is an abstract class - each box type
/// is a subclass of QBox (FilterQBox, JoinQBox, etc.).
///
/// A new QBox with the given type is allocated with:  instantiate(type)
///     See:  AuroraNode::create_add_task
///
/// Populate input descriptions using setInputDescription() to tell the QBox
/// what the input streams will look like.
///
/// Call setup() to invokes the QBox implementation's setupImpl();
/// which does one of the following:
///
///     * if a typing (or other) error occurs, throws an AuroraTypingException
///       (in which case the QBox is invalid and should just be deleted).
///
///     * if setup succeeded, sets the list of output stream descriptions.
///
///     For example, JoinQBox's setupImpl() method will verify that there
///     are exactly two input streams and that all the parameters make
///     sure (else throw an AuroraTypingException).  It will parse the
///     join predicate, saving the Predicate object in an instance
///     variable.  It will then create the output stream's description by
///     combining the two input descriptions the appropriate way, and
///     calling setOutputDescription(0, theNewDescription).
///
///     If only type inferencing or validation is desired, then at this
///     point the QBox can simply be destroyed.
///
/// The actual input and output streams themselves must be provided.
///     Up to this point only the descriptions have been specified.  Call:
///         setInput()   set the input streams
///         setOutput()  set the output streams
///
///     Each input stream must match the corresponding input description
///     provided.  Each output stream must match the output description
///     generated by typechecking.  Typechecking is performed on a local
///     node as Update XML is added to the catalog.
///
/// Initialize a box to be run by calling init(); which invokes initImpl().
///     This is the box's chance to initialize any state which is necessary
///     to run the box (beyond any state necessary to do type inferencing).
///
/// Boxes are executed periodically when the scheduler calls run(); which
///     calls runImpl(); which is responsible for processing tuples.
///     The runImpl() method should read tuples from TupleQueue::DeqIterators
///     (obtained by calling the protected deq() method) and outputs
///     tuples to Stream::EnqIterator (obtained by calling the protected
///     enq() method).
///
/// Boxes are deleted by AuroraNode::create_remove_task; which calls
///    _boxes.erase(box_names[i]) to deallocate the box.
///
///.............................................................................
///
/// These files need to be created or modified to add a new QBox:
///
///     <box type>QBox.h    Create these files to implement a new QBox
///     <box type>QBox.cc   and add them to an appropriate directory.
///
///        Intrinstic boxes that are part of the core borealis system.
///            borealis/src/modules/queryProcessor/boxes/
///
///        Internal boxes that are not visible to applications.
///            borealis/src/modules/queryProcessor/storageMgr/
///
///        User defined boxes created for various applications.
///            borealis/src/external/udb/
///
///        Special purposes boxed go in the corresponding directory.
///        For example Berkely Db boxes are in:  borealis/src/external/bdb/
///
///    <box directory>/Makefile.am    Extend the source list with the box files.
///
///    Add the box to the appropriate instantiate method.
///
///        Intrinstic and internal boxes modify:  instantiate
///            borealis/src/modules/queryProcessor/runtime/QBox.cc
///
///        User defined boxes modify:  instantiate_udb
///            borealis/src/external/udb/InstantiateUdb.cc
///
///        Berkely Db boxes modify:  instantiate_bdb
///            borealis/src/external/bdb/InstantiateBdb.cc
///
///        Array processing boxes modify:  instantiate_array
///            borealis/src/external/array/InstantiateArray.cc
///
///    borealis/src/modules/catalog/CatalogBox.h     Extend these to implement
///    borealis/src/modules/catalog/CatalogBox.cc    type checking for the box.
///
///.............................................................................


class QBox
{
  public:
    /// Determine the type of a box from a DOM &lt;box&gt; tag.  Throws an
    /// exception if the &lt;box&gt; tag doesn't seem to be valid.
    ///
    static string get_box_type(const DOMElement*)
                         throw(AuroraBadEntityException);


    /// Instantiate a box.
    /// Reimplementation to enable direct instantiation from the catalog???
    ///
    static QBox *instantiate(const string  &type)
                       throw(AuroraBadEntityException);


    /// Instantiate user boxes or, if none, run a stub returning NULL.
    ///
    static QBox *instantiate_udb(const string  &type);


    /// Instantiate Berkeley Db boxes or, if none, run a stub returning NULL.
    ///
    static QBox *instantiate_bdb(const string  &type);
    

    /// Instantiate array processing boxes or, if none, run a stub returning NULL.
    ///
    static QBox *instantiate_array(const string  &type);


    /// Destructor.
    virtual ~QBox();
    
    CatalogBox* get_catalog_box()
    {
        return _local_box;
    }

    /// Returns the table associated with this box, if any.
    Table *get_table() const
    {
        return _table;
    }

    /// Sets the table associated with this box.
    void set_table(Table *table)
    {
        assert(_state == CONSTRUCTED);
        _table = table;
    }

    /// Returns the description of the <i>i</i>th input stream,
    /// zero-relative.  Undefined behavior if no such input stream
    /// exists.
    ///
    CatalogSchema  *get_in_schema( uint16  port ) const
    {
        assert( port < _local_box->get_box_in()->size() );
        return( _local_box->get_in_schema( port ));
    }

    /// Returns the <i>i</i>th input stream definition, zero-relative.
    /// Undefined behavior if no such input stream exists.
    ///
    CatalogStream  *get_in_stream( uint16  port ) const
    {
        assert( port < _local_box->get_box_in()->size() );
        return( _local_box->get_in_stream( port ));
    }


    /// Returns the description of the <i>i</i>th output stream,
    /// zero-relative.  Undefined behavior if no such output stream
    /// exists.
    ///
    CatalogSchema  *get_out_schema( uint16 port ) const
    {
        assert( port < _local_box->get_box_out()->size() );
        return( _local_box->get_out_schema( port ));
    }

    /// Returns the <i>i</i>th input stream definition, zero-relative.
    /// Undefined behavior if no such input stream exists.
    ///
    CatalogStream  *get_out_stream( uint16  port ) const
    {
        assert( port < _local_box->get_box_out()->size() );
        return( _local_box->get_out_stream( port ));
    }


    /// Sets the description of the <i>i</i>th output stream,
    /// zero-relative.
    ///
    void set_out_description( uint16   port,
                     CatalogStream  *stream )
    {
        assert( _state == CONSTRUCTED );
        assert( port < 1000 );

        if ( _local_box->get_box_out()->size() <= port )
        {   _local_box->get_box_out()->resize( port + 1 );
        }

        //_local_box->_out[ port ]->_schema = stream->_schema;
        _local_box->set_out_schema( port, stream->get_stream_schema() );
        return;
    }

    void set_out_description( uint16  port,
                const TupleDescription& desc )
    {
        assert( _state == CONSTRUCTED );
        assert( port < 1000 );
        if ( _local_box->get_box_out()->size() <= port )
        {
            _local_box->get_box_out()->resize( port + 1 );
        }

        // fix
        // Some output schemas may not exist in the catalog.
        // Would be nice to actually copy the schema into the catalog.
        //_local_box->_out[ port ]->_schema->clone(*desc.getSchema());
        //_local_box->_out[ port ]->_schema = desc.getSchema();
        _local_box->set_out_schema( port, desc.get_schema() );
    }


    /// Returns the <i>i</i>th input stream.  Undefined behavior if no
    /// such input stream exists.
    Stream  &get_input(unsigned int n) const
    {
        assert(n < _inputs.size());
        return *(_inputs[n]);
    }

    ptr<TupleQueue> get_input_tuple_queue( unsigned int n ) const
    {
        assert( n < _inq.size() );
        return _inq[n];
    }

    /// Sets the <i>i</i>th input stream.
    void set_input(unsigned int i, Stream *desc)
    {
        assert(_state == CONSTRUCTED || _state == SETUP);
        assert(i < 1000);
        if (_inputs.size() <= i)
            _inputs.resize(i + 1);
        _inputs[i] = desc;
    }

    /// Returns the <i>i</i>th output stream.  Undefined behavior if no
    /// such input stream exists.
    Stream  &get_output(unsigned int n) const
    {
        assert(n < _outputs.size());
        return *(_outputs[n]);
    }

    /// Sets the <i>i</i>th output stream.
    void set_output(unsigned int i, Stream *desc);


    /// Returns the number of input streams.
    uint32  get_num_inputs()
    {   return( _local_box->get_box_in()->size() );
    }


    /// Returns the number of output streams.
    uint32  get_num_outputs()
    {   return( _local_box->get_box_out()->size() );
    }


    /// Returns the name of the box.
    string  get_name() const
    {   return( to_string( _local_box->get_box_name() ));
    }


    /// Returns the type of the box.
    string  getType() const
    {   return( _local_box->get_box_type() );
    }


    /// Returns a string representation of the box.
    string  as_string() const;

    /// Set up the box.  (The box must not have been setup or inited yet.)
    /// See the QBox lifecycle overview.

    //void setup(AuroraNode&, const DOMElement* elt) throw (AuroraException);
    void setup(AuroraNode&, CatalogBox* box) throw (AuroraException);

    virtual void update_params() { } // -- tatbul

    /// Initialize the box.  Calls setup() if setup has not yet been invoked.
    /// (The box must not have been inited already.)
    void init(PagePool& pool) throw (AuroraException);


    // Queue packing is common to all boxes.
    void set_pending_queue_state(ptr<QueueState> packed_queues) { _pending_queue_state = packed_queues; }
    void unpack_queue(ptr<QueueState> packed_queue); // Added by Magda
    void clear_queue(ptr<QueueState> packed_queue); // Added by Magda: need to empty the queue before unpacking
    ptr<QueueState> pack_queues() { return ptr<QueueState>(new QueueState(_inq)); };

    // State packing is box specific.
    virtual void set_pending_box_state(ptr<AbstractBoxState> packed_box) { _pending_box_state = packed_box; }
    virtual void unpack_state(ptr<AbstractBoxState> box_state) {};
    virtual ptr<AbstractBoxState> pack_state(bool delta_only = false) { return ptr<AbstractBoxState>(); };
    // When running a checkpoint, we must make sure that all boxes are in stable state
    virtual bool is_stable_for_checkpoint() { return true; }

    // When restarting processing from a local checkpoint, we should not touch the 
    // input queues of SUnions placed on input streams
    virtual bool do_unpack_queues() { return true; }
    
    virtual Time get_expected_capture_cost();

    virtual Time get_expected_paste_cost();


    /// Runs the QBox.  Should be called only by the scheduler.
    void run(QBoxInvocation& inv)
    {
        _more_processing = false;
        run_impl(inv);
    }


    /// Requests that the box get run again.  (Currently just calls
    /// notifyEnq() on the first input stream, which is a hack.)
    /// NOTE: This does not work for input boxes because the scheduler
    /// keeps the lock and prevents these boxes from adding themselves
    void schedule_run() { get_input(0).notify_enq(); }

    /// moreProcessing should be used when box voluntarily releases CPU
    /// but it is not done and should be re-scheduled.
    bool _more_processing;
    void more_processing() 
    { 
        _more_processing = true; 
    }
    bool has_more_processing() 
    { 
        return _more_processing; 
    }

    /// Returns the input queue corresponding to the <i>input</i>th
    /// input stream.
    TupleQueue *get_input_queue(unsigned int input) 
    { 
        return _inq[input].get();
    }

    static const BoxParameter::required PARAM_NOT_REQUIRED = 
                                            BoxParameter::NOT_REQUIRED;
    static const BoxParameter::required PARAM_REQUIRED     = 
                                            BoxParameter::REQUIRED;
    static const BoxParameter::required PARAM_NON_EMPTY    = 
                                            BoxParameter::NON_EMPTY;

    // Return a parameter.  See Params::param().
    string param( string name, BoxParameter::required req = PARAM_NOT_REQUIRED ) const
           throw( AuroraBadEntityException )
    {
        return( _local_box->get_box_parameter()->parameter( name, req ));
    }

    // Return a parameter.  See Params::param().
    string param( string name, string def ) const
    {
        return( _local_box->get_box_parameter()->parameter( name, def ));
    }

    void set_local_box_params(BoxParameter::ParameterMap *pm)
    {
        _local_box->get_box_parameter()->set_parameter_map(pm);
    }

    // Return a parameter.  See Params::typedParam().
    template <typename T>
    bool typed_param(string name, T& value,
                     BoxParameter::required req = PARAM_NOT_REQUIRED
                   ) const
              throw( AuroraBadEntityException )
    {
        return( _local_box->get_box_parameter()->typed_parameter( name, value, req ));
    }

    // not in use
    //const BoxParameter  *getParams()
    //{   return( _local_box->getBoxParameter() );
    //}

    bool get_emit_hist() const
    {
        return( _emit_hist );
    }
    
    void set_emit_hist( bool eh )
    {
        _emit_hist = eh;
    }

    // returns the "revised_values" from the tuples
    string get_revised_val( Tuple &t, CatalogSchema &s ) const;
    void set_revised_val( Tuple &t, CatalogSchema &s, string data );
    
    // returns the anchors
    vector<string> get_anchors() 
      {
    return _anchor;
      }
    
    // return the local_boxid of this box 
    int get_id() 
      {
    return _local_boxid;
      }

    // add Sweeper s to the vector of sweepers that work for this box
    void add_sweeper(ptr<QBox> s) 
      {
    _sweeper_box.push_back(s);
      }
    
////////////// beginning of methods for HA (by Jeong-Hyon)    

    /* 
     * Sets the HA Unit that this QBox belongs to. 
     */
    void set_ha_unit(ptr<HAUnit> ha_unit);

    /* 
     * Returns the  HA Unit that this QBox belongs to. 
     */
    ptr<HAUnit> get_ha_unit();

    /* 
     * Determines if this QBox is a backup.
     */
    bool is_backup();

    /* 
     * Marks that this QBox is a backup.
     */
    void set_backup();

    /* 
     * Returns whether this QBox is a passive image or not.
     */
    bool is_passive();
    
    /* 
     * Makes this QBox is schedulable and thereby executable.
     */
    void activate();
    
    /* 
     * Turn this QBox is unschedulable and thereby non-executable (i.e., a passive image)
     */
    void deactivate();
    
    double get_staleness();
////////////// end of fields methods HA (by Jeong-Hyon)    
    
  protected:

    // FOR REVISION PROCESSING
    enum RevisionProcessingMode
    {
        NONE,           // default, no mode set
        UPSTREAM,
        DOWNSTREAM
    };

    RevisionProcessingMode _revision_processing_mode;
    bool _emit_hist;
    bool _invertible;   // is this box invertible or not?

    // For downstream processing.
    // local_boxid - assigned by AuroraNode
    int _local_boxid;  
    
    // vector of sweepers that work for this box
    vector<ptr<QBox> > _sweeper_box;

    // names of the anchor CP's for this box
    vector<string> _anchor;
    
    // Query sweepers with NOTIFICATION tuple
    // return HISTORICAL, clear request from sweepers' buffers
    uint8 *retrieve_historical(uint8  *data);
    
    // Sends the tuple (either REQUEST or HISTORICAL) to the box's sweepers
    void send_to_sweeper(uint8  *data);
    
    // We dequeue from TupleQueues, and enqueue to Streams.
    typedef TupleQueue::DeqIterator DeqIterator;
    typedef Stream::EnqIterator EnqIterator;
    typedef TupleQueue::SeekIterator SeekIterator;

    QBox();

    // Called by runImpl(); returns a DeqIterator for the ith input port.
    DeqIterator deq(unsigned int index) { return _inq[index]->deq_iterator(); }

    // Called by runImpl(); returns a DeqIterator for the ith input port.
    SeekIterator seek(unsigned int index) { return _inq[index]->seek_iterator(); }

    // Called by runImpl(); returns an EnqIterator for the ith input port.
    EnqIterator enq(unsigned int index) { return _outputs[index]->enq_iterator(); }

    // METHODS TO IMPLEMENT IN SUBCLASSES:

    // Do preparing
    virtual void setup_impl() = 0;

    // Do whatever's necessary to init the box
    virtual void init_impl() {}

    // Run the thing
    virtual void run_impl(QBoxInvocation&) {}

    ptr<LockSet> get_lock_set(string name);

    ptr<AbstractBoxState> _pending_box_state;

    AuroraNode *_node; //moved away from private for now  ...


    /*** The following are public to let other components set the mode of the box ***/
 public:

    RevisionProcessingMode get_revision_processing_mode() const
      {
    return _revision_processing_mode;
      }
    
    void set_revision_processing_mode( RevisionProcessingMode mode )
      {
    assert(mode == NONE || mode == UPSTREAM || mode == DOWNSTREAM);
    _revision_processing_mode = mode;
      }

  private:

    void unpack_queue(Stream& stream, TupleQueue::EnqIterator enq);

    enum State
    {
        CONSTRUCTED,
        SETUP,
        INITED,
        DEAD
    };

    State _state;

    // Box declaration in the local catalog.
    //
    CatalogBox   *_local_box;

    Table *_table;                // should be replace by catalog???

    vector<Stream*> _inputs, _outputs;

    vector< ptr<TupleQueue> > _inq;

    ptr<QueueState> _pending_queue_state;

    ptr<Scheduler::BoxData> _sched_data;
    

    friend class QBoxInvocation;
    friend class Scheduler; // for _sched_data
    
////////////// beginning of fields for HA (by Jeong-Hyon)    
    protected:
    
    /* 
     * A flag that describes whether it's a backup. or not.
     */
    bool _backup;     
    
    /* 
     * A flag that describes whether it's a passive image or not (a backup can be active).
     */
    bool _passive;     
    
    /* 
     * The HA unit that this QBox belongs to. 
     */
    ptr<HAUnit> _ha_unit; 
    
////////////// end of fields for HA (by Jeong-Hyon)    
};


/// Runtime parameters for a QBox provided by the scheduler.  This
/// object is passed to a QBox's runImpl() method and contains
/// information specific to a particular invocation of the box, e.g.,
/// how many tuples to process.
class QBoxInvocation
{
  public:
    QBoxInvocation() : _tuples_dequeued( 0 ), _box(0), _end_time(0), _next_tick(1){}

    /// Return the maximum tuples that should be dequeued on a
    /// particular input port.  Deprecated (use continueDequeueOn instead).
    unsigned int get_max_tuples_to_dequeue(unsigned int input_port) const
    {
        return numeric_limits<int>::max();
    }

    /// Should the caller continue to process tuples from a particular
    /// input?  Guaranteed to return false if !deq.avail().
    bool continue_dequeue_on(QBox::DeqIterator deq, unsigned int input_port) const;

    // continueDequeueOn does not seem to do what it claims to do
    // i.e. it uses "processedsofar" from TupleQueue which is never reset
    // thus setting a _tuple_limit results in stalled execution once the
    // limit is reached. This is to be used to compare to _tuple_limit
    // instead of the current version.
    // Therefore the boxes should maintain this counter as they run.
    // It is also techincally wrong since there is a single counter, thus
    // single limit. but we migth want another controlling mechanism so
    // I am not going to make it too complicated now.
    mutable unsigned int _tuples_dequeued;

    // Public members for now
    QBox* _box;

    vector<unsigned int> _tuple_limit;
    unsigned long _end_time;

    mutable unsigned long _last_ticks;
    mutable unsigned int _next_tick;

    unsigned long ticks() const
    {
        if (!--_next_tick)
        {
            _next_tick = CALLS_BETWEEN_TICK;
            _last_ticks = Scheduler::ticks();
        }

        return _last_ticks;
    }

    static const int CALLS_BETWEEN_TICK = 1;
};


inline bool QBoxInvocation::continue_dequeue_on(QBox::DeqIterator deq, unsigned int input_port) const
{
    if (!deq.avail())
    {
        _tuples_dequeued = 0; // We should reset this every time. - Nesime
        return false;
    }

    _tuples_dequeued++;

    //cout << " Box is here, t_sz " << _tuple_limit.size() << " num dequeued " << _box->getInputQueue(input_port) << " tuple limit " << ( _tuple_limit.size() ? _tuple_limit[input_port] : 0 ) << " already dequeued " << _tuples_dequeued << endl;

    if (_box && _tuple_limit.size() &&
    // the explanation of _tuples_dequeued for this commented line.
        //_box->getInputQueue(input_port)->getNumTuplesDequeued() >= _tuple_limit[input_port])
        _tuples_dequeued >= _tuple_limit[input_port] )
    {
        _tuples_dequeued = 0;
        return false;
    }
    if (_end_time && ticks() >= _end_time)
    {
        _tuples_dequeued = 0; // We should reset this every time. - Nesime
        return false;
    }

    return true;
}

// Due to circular dependency in QBox, Scheduler (ick)
inline void Scheduler::set_box_data(QBox& box, ptr<BoxData> data)
{
    box._sched_data = data;
}

inline Scheduler::BoxData* Scheduler::get_box_data(const QBox& box) const
{
    return box._sched_data.get();
}

BOREALIS_NAMESPACE_END

#endif                           // QBOX_H
