/** \file
 *  This C header file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : SQL.g
 *     -                            On : 2011-10-10 18:39:50
 *     -                 for the lexer : SQLLexerLexer
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
 * The lexer 
SQLLexer

has the callable functions (rules) shown below,
 * which will invoke the code for the associated rule in the source grammar
 * assuming that the input stream is pointing to a token/text stream that could begin
 * this rule.
 *
 * For instance if you call the first (topmost) rule in a parser grammar, you will
 * get the results of a full parse, but calling a rule half way through the grammar will
 * allow you to pass part of a full token stream to the parser, such as for syntax checking
 * in editors and so on.
 *
 * The parser entry points are called indirectly (by function pointer to function) via
 * a parser context typedef pSQLLexer, which is returned from a call to SQLLexerNew().
 *
 * As this is a generated lexer, it is unlikely you will call it 'manually'. However
 * the methods are provided anyway.
 *
 * The methods in pSQLLexer are  as follows:
 *
 *  - 
 void
      pSQLLexer->KW_TRUE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_FALSE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_ALL(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_AND(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_OR(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_NOT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_LIKE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_IF(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_EXISTS(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_ASC(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_DESC(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_ORDER(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_GROUP(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_BY(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_HAVING(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_WHERE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_FROM(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_AS(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_SELECT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_DISTINCT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_INSERT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_OVERWRITE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_OUTER(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_UNIQUEJOIN(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_PRESERVE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_JOIN(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_LEFT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_RIGHT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_FULL(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_ON(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_PARTITION(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_PARTITIONS(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_TABLE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_TABLES(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_INDEX(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_INDEXES(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_REBUILD(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_FUNCTIONS(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_SHOW(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_MSCK(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_REPAIR(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_DIRECTORY(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_LOCAL(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_TRANSFORM(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_USING(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_CLUSTER(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_DISTRIBUTE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_SORT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_UNION(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_LOAD(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_DATA(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_INPATH(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_IS(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_NULL(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_CREATE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_EXTERNAL(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_ALTER(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_CHANGE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_COLUMN(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_FIRST(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_AFTER(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_DESCRIBE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_DROP(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_RENAME(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_TO(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_COMMENT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_BOOLEAN(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_TINYINT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_SMALLINT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_INT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_BIGINT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_FLOAT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_DOUBLE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_DATE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_DATETIME(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_TIMESTAMP(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_STRING(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_ARRAY(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_STRUCT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_MAP(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_UNIONTYPE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_REDUCE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_PARTITIONED(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_CLUSTERED(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_SORTED(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_INTO(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_BUCKETS(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_ROW(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_FORMAT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_DELIMITED(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_FIELDS(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_TERMINATED(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_ESCAPED(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_COLLECTION(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_ITEMS(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_KEYS(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_KEY_TYPE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_LINES(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_STORED(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_FILEFORMAT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_SEQUENCEFILE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_TEXTFILE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_RCFILE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_INPUTFORMAT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_OUTPUTFORMAT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_INPUTDRIVER(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_OUTPUTDRIVER(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_OFFLINE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_ENABLE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_DISABLE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_READONLY(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_NO_DROP(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_LOCATION(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_TABLESAMPLE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_BUCKET(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_OUT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_OF(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_CAST(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_ADD(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_REPLACE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_COLUMNS(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_RLIKE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_REGEXP(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_TEMPORARY(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_FUNCTION(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_EXPLAIN(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_EXTENDED(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_FORMATTED(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_SERDE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_WITH(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_DEFERRED(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_SERDEPROPERTIES(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_DBPROPERTIES(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_LIMIT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_SET(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_TBLPROPERTIES(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_IDXPROPERTIES(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_VALUE_TYPE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_ELEM_TYPE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_CASE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_WHEN(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_THEN(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_ELSE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_END(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_MAPJOIN(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_STREAMTABLE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_HOLD_DDLTIME(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_CLUSTERSTATUS(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_UTC(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_UTCTIMESTAMP(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_LONG(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_DELETE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_PLUS(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_MINUS(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_FETCH(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_INTERSECT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_VIEW(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_IN(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_DATABASE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_DATABASES(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_MATERIALIZED(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_SCHEMA(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_SCHEMAS(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_GRANT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_REVOKE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_SSL(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_UNDO(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_LOCK(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_LOCKS(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_UNLOCK(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_SHARED(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_EXCLUSIVE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_PROCEDURE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_UNSIGNED(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_WHILE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_READ(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_READS(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_PURGE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_RANGE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_ANALYZE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_BEFORE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_BETWEEN(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_BOTH(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_BINARY(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_CROSS(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_CONTINUE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_CURSOR(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_TRIGGER(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_RECORDREADER(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_RECORDWRITER(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_SEMI(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_LATERAL(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_TOUCH(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_ARCHIVE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_UNARCHIVE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_COMPUTE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_STATISTICS(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_USE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_OPTION(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_SHOW_DATABASE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_UPDATE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_INPUT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_OUTPUT(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_STREAM(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_WINDOW(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_SIZE(pSQLLexer)
 *  - 
 void
      pSQLLexer->KW_ADVANCE(pSQLLexer)
 *  - 
 void
      pSQLLexer->DOT(pSQLLexer)
 *  - 
 void
      pSQLLexer->COLON(pSQLLexer)
 *  - 
 void
      pSQLLexer->COMMA(pSQLLexer)
 *  - 
 void
      pSQLLexer->SEMICOLON(pSQLLexer)
 *  - 
 void
      pSQLLexer->LPAREN(pSQLLexer)
 *  - 
 void
      pSQLLexer->RPAREN(pSQLLexer)
 *  - 
 void
      pSQLLexer->LSQUARE(pSQLLexer)
 *  - 
 void
      pSQLLexer->RSQUARE(pSQLLexer)
 *  - 
 void
      pSQLLexer->LCURLY(pSQLLexer)
 *  - 
 void
      pSQLLexer->RCURLY(pSQLLexer)
 *  - 
 void
      pSQLLexer->EQUAL(pSQLLexer)
 *  - 
 void
      pSQLLexer->NOTEQUAL(pSQLLexer)
 *  - 
 void
      pSQLLexer->LESSTHANOREQUALTO(pSQLLexer)
 *  - 
 void
      pSQLLexer->LESSTHAN(pSQLLexer)
 *  - 
 void
      pSQLLexer->GREATERTHANOREQUALTO(pSQLLexer)
 *  - 
 void
      pSQLLexer->GREATERTHAN(pSQLLexer)
 *  - 
 void
      pSQLLexer->DIVIDE(pSQLLexer)
 *  - 
 void
      pSQLLexer->PLUS(pSQLLexer)
 *  - 
 void
      pSQLLexer->MINUS(pSQLLexer)
 *  - 
 void
      pSQLLexer->STAR(pSQLLexer)
 *  - 
 void
      pSQLLexer->MOD(pSQLLexer)
 *  - 
 void
      pSQLLexer->DIV(pSQLLexer)
 *  - 
 void
      pSQLLexer->AMPERSAND(pSQLLexer)
 *  - 
 void
      pSQLLexer->TILDE(pSQLLexer)
 *  - 
 void
      pSQLLexer->BITWISEOR(pSQLLexer)
 *  - 
 void
      pSQLLexer->BITWISEXOR(pSQLLexer)
 *  - 
 void
      pSQLLexer->QUESTION(pSQLLexer)
 *  - 
 void
      pSQLLexer->DOLLAR(pSQLLexer)
 *  - 
 void
      pSQLLexer->Letter(pSQLLexer)
 *  - 
 void
      pSQLLexer->HexDigit(pSQLLexer)
 *  - 
 void
      pSQLLexer->Digit(pSQLLexer)
 *  - 
 void
      pSQLLexer->Exponent(pSQLLexer)
 *  - 
 void
      pSQLLexer->RegexComponent(pSQLLexer)
 *  - 
 void
      pSQLLexer->StringLiteral(pSQLLexer)
 *  - 
 void
      pSQLLexer->CharSetLiteral(pSQLLexer)
 *  - 
 void
      pSQLLexer->Number(pSQLLexer)
 *  - 
 void
      pSQLLexer->Identifier(pSQLLexer)
 *  - 
 void
      pSQLLexer->CharSetName(pSQLLexer)
 *  - 
 void
      pSQLLexer->WS(pSQLLexer)
 *  - 
 void
      pSQLLexer->COMMENT(pSQLLexer)
 *  - 
 void
      pSQLLexer->Tokens(pSQLLexer)
 *
 * The return type for any particular rule is of course determined by the source
 * grammar file.
 */
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#ifndef	_SQLLexer_H
#define _SQLLexer_H
/* =============================================================================
 * Standard antlr3 C runtime definitions
 */
#include    <antlr3.h>

/* End of standard antlr 3 runtime definitions
 * =============================================================================
 */

#ifdef __cplusplus
extern "C" {
#endif

// Forward declare the context typedef so that we can use it before it is
// properly defined. Delegators and delegates (from import statements) are
// interdependent and their context structures contain pointers to each other
// C only allows such things to be declared if you pre-declare the typedef.
//
typedef struct SQLLexer_Ctx_struct SQLLexer, * pSQLLexer;



#ifdef	ANTLR3_WINDOWS
// Disable: Unreferenced parameter,							- Rules with parameters that are not used
//          constant conditional,							- ANTLR realizes that a prediction is always true (synpred usually)
//          initialized but unused variable					- tree rewrite variables declared but not needed
//          Unreferenced local variable						- lexer rule declares but does not always use _type
//          potentially unitialized variable used			- retval always returned from a rule
//			unreferenced local function has been removed	- susually getTokenNames or freeScope, they can go without warnigns
//
// These are only really displayed at warning level /W4 but that is the code ideal I am aiming at
// and the codegen must generate some of these warnings by necessity, apart from 4100, which is
// usually generated when a parser rule is given a parameter that it does not use. Mostly though
// this is a matter of orthogonality hence I disable that one.
//
#pragma warning( disable : 4100 )
#pragma warning( disable : 4101 )
#pragma warning( disable : 4127 )
#pragma warning( disable : 4189 )
#pragma warning( disable : 4505 )
#pragma warning( disable : 4701 )
#endif

/** Context tracking structure for 
SQLLexer

 */
struct SQLLexer_Ctx_struct
{
    /** Built in ANTLR3 context tracker contains all the generic elements
     *  required for context tracking.
     */
    pANTLR3_LEXER    pLexer;

     void
     (*mKW_TRUE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_FALSE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_ALL)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_AND)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_OR)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_NOT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_LIKE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_IF)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_EXISTS)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_ASC)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_DESC)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_ORDER)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_GROUP)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_BY)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_HAVING)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_WHERE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_FROM)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_AS)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_SELECT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_DISTINCT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_INSERT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_OVERWRITE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_OUTER)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_UNIQUEJOIN)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_PRESERVE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_JOIN)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_LEFT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_RIGHT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_FULL)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_ON)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_PARTITION)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_PARTITIONS)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_TABLE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_TABLES)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_INDEX)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_INDEXES)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_REBUILD)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_FUNCTIONS)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_SHOW)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_MSCK)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_REPAIR)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_DIRECTORY)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_LOCAL)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_TRANSFORM)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_USING)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_CLUSTER)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_DISTRIBUTE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_SORT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_UNION)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_LOAD)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_DATA)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_INPATH)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_IS)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_NULL)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_CREATE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_EXTERNAL)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_ALTER)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_CHANGE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_COLUMN)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_FIRST)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_AFTER)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_DESCRIBE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_DROP)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_RENAME)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_TO)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_COMMENT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_BOOLEAN)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_TINYINT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_SMALLINT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_INT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_BIGINT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_FLOAT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_DOUBLE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_DATE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_DATETIME)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_TIMESTAMP)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_STRING)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_ARRAY)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_STRUCT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_MAP)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_UNIONTYPE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_REDUCE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_PARTITIONED)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_CLUSTERED)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_SORTED)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_INTO)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_BUCKETS)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_ROW)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_FORMAT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_DELIMITED)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_FIELDS)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_TERMINATED)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_ESCAPED)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_COLLECTION)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_ITEMS)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_KEYS)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_KEY_TYPE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_LINES)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_STORED)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_FILEFORMAT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_SEQUENCEFILE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_TEXTFILE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_RCFILE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_INPUTFORMAT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_OUTPUTFORMAT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_INPUTDRIVER)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_OUTPUTDRIVER)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_OFFLINE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_ENABLE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_DISABLE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_READONLY)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_NO_DROP)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_LOCATION)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_TABLESAMPLE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_BUCKET)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_OUT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_OF)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_CAST)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_ADD)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_REPLACE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_COLUMNS)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_RLIKE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_REGEXP)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_TEMPORARY)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_FUNCTION)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_EXPLAIN)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_EXTENDED)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_FORMATTED)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_SERDE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_WITH)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_DEFERRED)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_SERDEPROPERTIES)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_DBPROPERTIES)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_LIMIT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_SET)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_TBLPROPERTIES)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_IDXPROPERTIES)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_VALUE_TYPE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_ELEM_TYPE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_CASE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_WHEN)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_THEN)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_ELSE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_END)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_MAPJOIN)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_STREAMTABLE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_HOLD_DDLTIME)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_CLUSTERSTATUS)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_UTC)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_UTCTIMESTAMP)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_LONG)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_DELETE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_PLUS)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_MINUS)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_FETCH)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_INTERSECT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_VIEW)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_IN)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_DATABASE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_DATABASES)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_MATERIALIZED)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_SCHEMA)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_SCHEMAS)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_GRANT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_REVOKE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_SSL)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_UNDO)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_LOCK)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_LOCKS)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_UNLOCK)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_SHARED)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_EXCLUSIVE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_PROCEDURE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_UNSIGNED)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_WHILE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_READ)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_READS)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_PURGE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_RANGE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_ANALYZE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_BEFORE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_BETWEEN)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_BOTH)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_BINARY)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_CROSS)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_CONTINUE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_CURSOR)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_TRIGGER)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_RECORDREADER)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_RECORDWRITER)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_SEMI)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_LATERAL)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_TOUCH)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_ARCHIVE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_UNARCHIVE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_COMPUTE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_STATISTICS)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_USE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_OPTION)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_SHOW_DATABASE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_UPDATE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_INPUT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_OUTPUT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_STREAM)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_WINDOW)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_SIZE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mKW_ADVANCE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mDOT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mCOLON)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mCOMMA)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mSEMICOLON)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mLPAREN)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mRPAREN)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mLSQUARE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mRSQUARE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mLCURLY)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mRCURLY)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mEQUAL)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mNOTEQUAL)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mLESSTHANOREQUALTO)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mLESSTHAN)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mGREATERTHANOREQUALTO)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mGREATERTHAN)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mDIVIDE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mPLUS)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mMINUS)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mSTAR)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mMOD)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mDIV)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mAMPERSAND)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mTILDE)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mBITWISEOR)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mBITWISEXOR)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mQUESTION)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mDOLLAR)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mLetter)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mHexDigit)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mDigit)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mExponent)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mRegexComponent)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mStringLiteral)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mCharSetLiteral)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mNumber)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mIdentifier)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mCharSetName)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mWS)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mCOMMENT)	(struct SQLLexer_Ctx_struct * ctx);

     void
     (*mTokens)	(struct SQLLexer_Ctx_struct * ctx);
    const char * (*getGrammarFileName)();
    void            (*reset)  (struct SQLLexer_Ctx_struct * ctx);
    void	    (*free)   (struct SQLLexer_Ctx_struct * ctx);
};

// Function protoypes for the constructor functions that external translation units
// such as delegators and delegates may wish to call.
//
ANTLR3_API pSQLLexer SQLLexerNew         (
pANTLR3_INPUT_STREAM
 instream);
ANTLR3_API pSQLLexer SQLLexerNewSSD      (
pANTLR3_INPUT_STREAM
 instream, pANTLR3_RECOGNIZER_SHARED_STATE state);

/** Symbolic definitions of all the tokens that the 
lexer
 will work with.
 * \{
 *
 * Antlr will define EOF, but we can't use that as it it is too common in
 * in C header files and that would be confusing. There is no way to filter this out at the moment
 * so we just undef it here for now. That isn't the value we get back from C recognizers
 * anyway. We are looking for ANTLR3_TOKEN_EOF.
 */
#ifdef	EOF
#undef	EOF
#endif
#ifdef	Tokens
#undef	Tokens
#endif
#define EOF      -1
#define AMPERSAND      4
#define BITWISEOR      5
#define BITWISEXOR      6
#define COLON      7
#define COMMA      8
#define COMMENT      9
#define CharSetLiteral      10
#define CharSetName      11
#define DIV      12
#define DIVIDE      13
#define DOLLAR      14
#define DOT      15
#define Digit      16
#define EQUAL      17
#define Exponent      18
#define GREATERTHAN      19
#define GREATERTHANOREQUALTO      20
#define HexDigit      21
#define Identifier      22
#define KW_ADD      23
#define KW_ADVANCE      24
#define KW_AFTER      25
#define KW_ALL      26
#define KW_ALTER      27
#define KW_ANALYZE      28
#define KW_AND      29
#define KW_ARCHIVE      30
#define KW_ARRAY      31
#define KW_AS      32
#define KW_ASC      33
#define KW_BEFORE      34
#define KW_BETWEEN      35
#define KW_BIGINT      36
#define KW_BINARY      37
#define KW_BOOLEAN      38
#define KW_BOTH      39
#define KW_BUCKET      40
#define KW_BUCKETS      41
#define KW_BY      42
#define KW_CASE      43
#define KW_CAST      44
#define KW_CHANGE      45
#define KW_CLUSTER      46
#define KW_CLUSTERED      47
#define KW_CLUSTERSTATUS      48
#define KW_COLLECTION      49
#define KW_COLUMN      50
#define KW_COLUMNS      51
#define KW_COMMENT      52
#define KW_COMPUTE      53
#define KW_CONTINUE      54
#define KW_CREATE      55
#define KW_CROSS      56
#define KW_CURSOR      57
#define KW_DATA      58
#define KW_DATABASE      59
#define KW_DATABASES      60
#define KW_DATE      61
#define KW_DATETIME      62
#define KW_DBPROPERTIES      63
#define KW_DEFERRED      64
#define KW_DELETE      65
#define KW_DELIMITED      66
#define KW_DESC      67
#define KW_DESCRIBE      68
#define KW_DIRECTORY      69
#define KW_DISABLE      70
#define KW_DISTINCT      71
#define KW_DISTRIBUTE      72
#define KW_DOUBLE      73
#define KW_DROP      74
#define KW_ELEM_TYPE      75
#define KW_ELSE      76
#define KW_ENABLE      77
#define KW_END      78
#define KW_ESCAPED      79
#define KW_EXCLUSIVE      80
#define KW_EXISTS      81
#define KW_EXPLAIN      82
#define KW_EXTENDED      83
#define KW_EXTERNAL      84
#define KW_FALSE      85
#define KW_FETCH      86
#define KW_FIELDS      87
#define KW_FILEFORMAT      88
#define KW_FIRST      89
#define KW_FLOAT      90
#define KW_FORMAT      91
#define KW_FORMATTED      92
#define KW_FROM      93
#define KW_FULL      94
#define KW_FUNCTION      95
#define KW_FUNCTIONS      96
#define KW_GRANT      97
#define KW_GROUP      98
#define KW_HAVING      99
#define KW_HOLD_DDLTIME      100
#define KW_IDXPROPERTIES      101
#define KW_IF      102
#define KW_IN      103
#define KW_INDEX      104
#define KW_INDEXES      105
#define KW_INPATH      106
#define KW_INPUT      107
#define KW_INPUTDRIVER      108
#define KW_INPUTFORMAT      109
#define KW_INSERT      110
#define KW_INT      111
#define KW_INTERSECT      112
#define KW_INTO      113
#define KW_IS      114
#define KW_ITEMS      115
#define KW_JOIN      116
#define KW_KEYS      117
#define KW_KEY_TYPE      118
#define KW_LATERAL      119
#define KW_LEFT      120
#define KW_LIKE      121
#define KW_LIMIT      122
#define KW_LINES      123
#define KW_LOAD      124
#define KW_LOCAL      125
#define KW_LOCATION      126
#define KW_LOCK      127
#define KW_LOCKS      128
#define KW_LONG      129
#define KW_MAP      130
#define KW_MAPJOIN      131
#define KW_MATERIALIZED      132
#define KW_MINUS      133
#define KW_MSCK      134
#define KW_NOT      135
#define KW_NO_DROP      136
#define KW_NULL      137
#define KW_OF      138
#define KW_OFFLINE      139
#define KW_ON      140
#define KW_OPTION      141
#define KW_OR      142
#define KW_ORDER      143
#define KW_OUT      144
#define KW_OUTER      145
#define KW_OUTPUT      146
#define KW_OUTPUTDRIVER      147
#define KW_OUTPUTFORMAT      148
#define KW_OVERWRITE      149
#define KW_PARTITION      150
#define KW_PARTITIONED      151
#define KW_PARTITIONS      152
#define KW_PLUS      153
#define KW_PRESERVE      154
#define KW_PROCEDURE      155
#define KW_PURGE      156
#define KW_RANGE      157
#define KW_RCFILE      158
#define KW_READ      159
#define KW_READONLY      160
#define KW_READS      161
#define KW_REBUILD      162
#define KW_RECORDREADER      163
#define KW_RECORDWRITER      164
#define KW_REDUCE      165
#define KW_REGEXP      166
#define KW_RENAME      167
#define KW_REPAIR      168
#define KW_REPLACE      169
#define KW_REVOKE      170
#define KW_RIGHT      171
#define KW_RLIKE      172
#define KW_ROW      173
#define KW_SCHEMA      174
#define KW_SCHEMAS      175
#define KW_SELECT      176
#define KW_SEMI      177
#define KW_SEQUENCEFILE      178
#define KW_SERDE      179
#define KW_SERDEPROPERTIES      180
#define KW_SET      181
#define KW_SHARED      182
#define KW_SHOW      183
#define KW_SHOW_DATABASE      184
#define KW_SIZE      185
#define KW_SMALLINT      186
#define KW_SORT      187
#define KW_SORTED      188
#define KW_SSL      189
#define KW_STATISTICS      190
#define KW_STORED      191
#define KW_STREAM      192
#define KW_STREAMTABLE      193
#define KW_STRING      194
#define KW_STRUCT      195
#define KW_TABLE      196
#define KW_TABLES      197
#define KW_TABLESAMPLE      198
#define KW_TBLPROPERTIES      199
#define KW_TEMPORARY      200
#define KW_TERMINATED      201
#define KW_TEXTFILE      202
#define KW_THEN      203
#define KW_TIMESTAMP      204
#define KW_TINYINT      205
#define KW_TO      206
#define KW_TOUCH      207
#define KW_TRANSFORM      208
#define KW_TRIGGER      209
#define KW_TRUE      210
#define KW_UNARCHIVE      211
#define KW_UNDO      212
#define KW_UNION      213
#define KW_UNIONTYPE      214
#define KW_UNIQUEJOIN      215
#define KW_UNLOCK      216
#define KW_UNSIGNED      217
#define KW_UPDATE      218
#define KW_USE      219
#define KW_USING      220
#define KW_UTC      221
#define KW_UTCTIMESTAMP      222
#define KW_VALUE_TYPE      223
#define KW_VIEW      224
#define KW_WHEN      225
#define KW_WHERE      226
#define KW_WHILE      227
#define KW_WINDOW      228
#define KW_WITH      229
#define LCURLY      230
#define LESSTHAN      231
#define LESSTHANOREQUALTO      232
#define LPAREN      233
#define LSQUARE      234
#define Letter      235
#define MINUS      236
#define MOD      237
#define NOTEQUAL      238
#define Number      239
#define PLUS      240
#define QUESTION      241
#define RCURLY      242
#define RPAREN      243
#define RSQUARE      244
#define RegexComponent      245
#define SEMICOLON      246
#define STAR      247
#define StringLiteral      248
#define TILDE      249
#define TOK_CREATE_SCHEMA      250
#define TOK_CREATE_STREAM      251
#define TOK_CREATE_WINDOW      252
#define TOK_NAME_TYPE      253
#define TOK_SCHEMA_LIST      254
#define TOK_SELECT      255
#define TOK_SELEXPR      256
#define TOK_SELITEM      257
#define TOK_SELLIST      258
#define WS      259
#ifdef	EOF
#undef	EOF
#define	EOF	ANTLR3_TOKEN_EOF
#endif

#ifndef TOKENSOURCE
#define TOKENSOURCE(lxr) lxr->pLexer->rec->state->tokSource
#endif

/* End of token definitions for SQLLexer
 * =============================================================================
 */
/** } */

#ifdef __cplusplus
}
#endif

#endif

/* END - Note:Keep extra line feed to satisfy UNIX systems */
