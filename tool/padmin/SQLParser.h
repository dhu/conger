/** \file
 *  This C header file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : SQL.g
 *     -                            On : 2011-10-10 18:39:49
 *     -                for the parser : SQLParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
 * The parser 
SQLParser

has the callable functions (rules) shown below,
 * which will invoke the code for the associated rule in the source grammar
 * assuming that the input stream is pointing to a token/text stream that could begin
 * this rule.
 *
 * For instance if you call the first (topmost) rule in a parser grammar, you will
 * get the results of a full parse, but calling a rule half way through the grammar will
 * allow you to pass part of a full token stream to the parser, such as for syntax checking
 * in editors and so on.
 *
 * The parser entry points are called indirectly (by function pointer to function) via
 * a parser context typedef pSQLParser, which is returned from a call to SQLParserNew().
 *
 * The methods in pSQLParser are  as follows:
 *
 *  - 
 SQLParser_statement_return
      pSQLParser->statement(pSQLParser)
 *  - 
 SQLParser_selectStatement_return
      pSQLParser->selectStatement(pSQLParser)
 *  - 
 SQLParser_selectList_return
      pSQLParser->selectList(pSQLParser)
 *  - 
 SQLParser_selectColumn_return
      pSQLParser->selectColumn(pSQLParser)
 *  - 
 SQLParser_selectItem_return
      pSQLParser->selectItem(pSQLParser)
 *  - 
 SQLParser_selectExpression_return
      pSQLParser->selectExpression(pSQLParser)
 *  - 
 SQLParser_createStatement_return
      pSQLParser->createStatement(pSQLParser)
 *  - 
 SQLParser_schemaList_return
      pSQLParser->schemaList(pSQLParser)
 *  - 
 SQLParser_streamType_return
      pSQLParser->streamType(pSQLParser)
 *  - 
 SQLParser_columnNameType_return
      pSQLParser->columnNameType(pSQLParser)
 *  - 
 SQLParser_dataType_return
      pSQLParser->dataType(pSQLParser)
 *
 * The return type for any particular rule is of course determined by the source
 * grammar file.
 */
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#ifndef	_SQLParser_H
#define _SQLParser_H
/* =============================================================================
 * Standard antlr3 C runtime definitions
 */
#include    <antlr3.h>

/* End of standard antlr 3 runtime definitions
 * =============================================================================
 */

#ifdef __cplusplus
extern "C" {
#endif

// Forward declare the context typedef so that we can use it before it is
// properly defined. Delegators and delegates (from import statements) are
// interdependent and their context structures contain pointers to each other
// C only allows such things to be declared if you pre-declare the typedef.
//
typedef struct SQLParser_Ctx_struct SQLParser, * pSQLParser;



#ifdef	ANTLR3_WINDOWS
// Disable: Unreferenced parameter,							- Rules with parameters that are not used
//          constant conditional,							- ANTLR realizes that a prediction is always true (synpred usually)
//          initialized but unused variable					- tree rewrite variables declared but not needed
//          Unreferenced local variable						- lexer rule declares but does not always use _type
//          potentially unitialized variable used			- retval always returned from a rule
//			unreferenced local function has been removed	- susually getTokenNames or freeScope, they can go without warnigns
//
// These are only really displayed at warning level /W4 but that is the code ideal I am aiming at
// and the codegen must generate some of these warnings by necessity, apart from 4100, which is
// usually generated when a parser rule is given a parameter that it does not use. Mostly though
// this is a matter of orthogonality hence I disable that one.
//
#pragma warning( disable : 4100 )
#pragma warning( disable : 4101 )
#pragma warning( disable : 4127 )
#pragma warning( disable : 4189 )
#pragma warning( disable : 4505 )
#pragma warning( disable : 4701 )
#endif
typedef struct SQLParser_statement_return_struct
{
    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees
     */
    pANTLR3_COMMON_TOKEN    start;
    pANTLR3_COMMON_TOKEN    stop;
    pANTLR3_BASE_TREE	tree;

}
    SQLParser_statement_return;



typedef struct SQLParser_selectStatement_return_struct
{
    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees
     */
    pANTLR3_COMMON_TOKEN    start;
    pANTLR3_COMMON_TOKEN    stop;
    pANTLR3_BASE_TREE	tree;

}
    SQLParser_selectStatement_return;



typedef struct SQLParser_selectList_return_struct
{
    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees
     */
    pANTLR3_COMMON_TOKEN    start;
    pANTLR3_COMMON_TOKEN    stop;
    pANTLR3_BASE_TREE	tree;

}
    SQLParser_selectList_return;



typedef struct SQLParser_selectColumn_return_struct
{
    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees
     */
    pANTLR3_COMMON_TOKEN    start;
    pANTLR3_COMMON_TOKEN    stop;
    pANTLR3_BASE_TREE	tree;

}
    SQLParser_selectColumn_return;



typedef struct SQLParser_selectItem_return_struct
{
    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees
     */
    pANTLR3_COMMON_TOKEN    start;
    pANTLR3_COMMON_TOKEN    stop;
    pANTLR3_BASE_TREE	tree;

}
    SQLParser_selectItem_return;



typedef struct SQLParser_selectExpression_return_struct
{
    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees
     */
    pANTLR3_COMMON_TOKEN    start;
    pANTLR3_COMMON_TOKEN    stop;
    pANTLR3_BASE_TREE	tree;

}
    SQLParser_selectExpression_return;



typedef struct SQLParser_createStatement_return_struct
{
    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees
     */
    pANTLR3_COMMON_TOKEN    start;
    pANTLR3_COMMON_TOKEN    stop;
    pANTLR3_BASE_TREE	tree;

}
    SQLParser_createStatement_return;



typedef struct SQLParser_schemaList_return_struct
{
    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees
     */
    pANTLR3_COMMON_TOKEN    start;
    pANTLR3_COMMON_TOKEN    stop;
    pANTLR3_BASE_TREE	tree;

}
    SQLParser_schemaList_return;



typedef struct SQLParser_streamType_return_struct
{
    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees
     */
    pANTLR3_COMMON_TOKEN    start;
    pANTLR3_COMMON_TOKEN    stop;
    pANTLR3_BASE_TREE	tree;

}
    SQLParser_streamType_return;



typedef struct SQLParser_columnNameType_return_struct
{
    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees
     */
    pANTLR3_COMMON_TOKEN    start;
    pANTLR3_COMMON_TOKEN    stop;
    pANTLR3_BASE_TREE	tree;

}
    SQLParser_columnNameType_return;



typedef struct SQLParser_dataType_return_struct
{
    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees
     */
    pANTLR3_COMMON_TOKEN    start;
    pANTLR3_COMMON_TOKEN    stop;
    pANTLR3_BASE_TREE	tree;

}
    SQLParser_dataType_return;




/** Context tracking structure for 
SQLParser

 */
struct SQLParser_Ctx_struct
{
    /** Built in ANTLR3 context tracker contains all the generic elements
     *  required for context tracking.
     */
    pANTLR3_PARSER   pParser;

     SQLParser_statement_return
     (*statement)	(struct SQLParser_Ctx_struct * ctx);

     SQLParser_selectStatement_return
     (*selectStatement)	(struct SQLParser_Ctx_struct * ctx);

     SQLParser_selectList_return
     (*selectList)	(struct SQLParser_Ctx_struct * ctx);

     SQLParser_selectColumn_return
     (*selectColumn)	(struct SQLParser_Ctx_struct * ctx);

     SQLParser_selectItem_return
     (*selectItem)	(struct SQLParser_Ctx_struct * ctx);

     SQLParser_selectExpression_return
     (*selectExpression)	(struct SQLParser_Ctx_struct * ctx);

     SQLParser_createStatement_return
     (*createStatement)	(struct SQLParser_Ctx_struct * ctx);

     SQLParser_schemaList_return
     (*schemaList)	(struct SQLParser_Ctx_struct * ctx);

     SQLParser_streamType_return
     (*streamType)	(struct SQLParser_Ctx_struct * ctx);

     SQLParser_columnNameType_return
     (*columnNameType)	(struct SQLParser_Ctx_struct * ctx);

     SQLParser_dataType_return
     (*dataType)	(struct SQLParser_Ctx_struct * ctx);
    // Delegated rules

    const char * (*getGrammarFileName)();
    void            (*reset)  (struct SQLParser_Ctx_struct * ctx);
    void	    (*free)   (struct SQLParser_Ctx_struct * ctx);
/* @headerFile.members() */
pANTLR3_BASE_TREE_ADAPTOR	adaptor;
pANTLR3_VECTOR_FACTORY		vectors;
/* End @headerFile.members() */
};

// Function protoypes for the constructor functions that external translation units
// such as delegators and delegates may wish to call.
//
ANTLR3_API pSQLParser SQLParserNew         (
pANTLR3_COMMON_TOKEN_STREAM
 instream);
ANTLR3_API pSQLParser SQLParserNewSSD      (
pANTLR3_COMMON_TOKEN_STREAM
 instream, pANTLR3_RECOGNIZER_SHARED_STATE state);

/** Symbolic definitions of all the tokens that the 
parser
 will work with.
 * \{
 *
 * Antlr will define EOF, but we can't use that as it it is too common in
 * in C header files and that would be confusing. There is no way to filter this out at the moment
 * so we just undef it here for now. That isn't the value we get back from C recognizers
 * anyway. We are looking for ANTLR3_TOKEN_EOF.
 */
#ifdef	EOF
#undef	EOF
#endif
#ifdef	Tokens
#undef	Tokens
#endif
#define EOF      -1
#define AMPERSAND      4
#define BITWISEOR      5
#define BITWISEXOR      6
#define COLON      7
#define COMMA      8
#define COMMENT      9
#define CharSetLiteral      10
#define CharSetName      11
#define DIV      12
#define DIVIDE      13
#define DOLLAR      14
#define DOT      15
#define Digit      16
#define EQUAL      17
#define Exponent      18
#define GREATERTHAN      19
#define GREATERTHANOREQUALTO      20
#define HexDigit      21
#define Identifier      22
#define KW_ADD      23
#define KW_ADVANCE      24
#define KW_AFTER      25
#define KW_ALL      26
#define KW_ALTER      27
#define KW_ANALYZE      28
#define KW_AND      29
#define KW_ARCHIVE      30
#define KW_ARRAY      31
#define KW_AS      32
#define KW_ASC      33
#define KW_BEFORE      34
#define KW_BETWEEN      35
#define KW_BIGINT      36
#define KW_BINARY      37
#define KW_BOOLEAN      38
#define KW_BOTH      39
#define KW_BUCKET      40
#define KW_BUCKETS      41
#define KW_BY      42
#define KW_CASE      43
#define KW_CAST      44
#define KW_CHANGE      45
#define KW_CLUSTER      46
#define KW_CLUSTERED      47
#define KW_CLUSTERSTATUS      48
#define KW_COLLECTION      49
#define KW_COLUMN      50
#define KW_COLUMNS      51
#define KW_COMMENT      52
#define KW_COMPUTE      53
#define KW_CONTINUE      54
#define KW_CREATE      55
#define KW_CROSS      56
#define KW_CURSOR      57
#define KW_DATA      58
#define KW_DATABASE      59
#define KW_DATABASES      60
#define KW_DATE      61
#define KW_DATETIME      62
#define KW_DBPROPERTIES      63
#define KW_DEFERRED      64
#define KW_DELETE      65
#define KW_DELIMITED      66
#define KW_DESC      67
#define KW_DESCRIBE      68
#define KW_DIRECTORY      69
#define KW_DISABLE      70
#define KW_DISTINCT      71
#define KW_DISTRIBUTE      72
#define KW_DOUBLE      73
#define KW_DROP      74
#define KW_ELEM_TYPE      75
#define KW_ELSE      76
#define KW_ENABLE      77
#define KW_END      78
#define KW_ESCAPED      79
#define KW_EXCLUSIVE      80
#define KW_EXISTS      81
#define KW_EXPLAIN      82
#define KW_EXTENDED      83
#define KW_EXTERNAL      84
#define KW_FALSE      85
#define KW_FETCH      86
#define KW_FIELDS      87
#define KW_FILEFORMAT      88
#define KW_FIRST      89
#define KW_FLOAT      90
#define KW_FORMAT      91
#define KW_FORMATTED      92
#define KW_FROM      93
#define KW_FULL      94
#define KW_FUNCTION      95
#define KW_FUNCTIONS      96
#define KW_GRANT      97
#define KW_GROUP      98
#define KW_HAVING      99
#define KW_HOLD_DDLTIME      100
#define KW_IDXPROPERTIES      101
#define KW_IF      102
#define KW_IN      103
#define KW_INDEX      104
#define KW_INDEXES      105
#define KW_INPATH      106
#define KW_INPUT      107
#define KW_INPUTDRIVER      108
#define KW_INPUTFORMAT      109
#define KW_INSERT      110
#define KW_INT      111
#define KW_INTERSECT      112
#define KW_INTO      113
#define KW_IS      114
#define KW_ITEMS      115
#define KW_JOIN      116
#define KW_KEYS      117
#define KW_KEY_TYPE      118
#define KW_LATERAL      119
#define KW_LEFT      120
#define KW_LIKE      121
#define KW_LIMIT      122
#define KW_LINES      123
#define KW_LOAD      124
#define KW_LOCAL      125
#define KW_LOCATION      126
#define KW_LOCK      127
#define KW_LOCKS      128
#define KW_LONG      129
#define KW_MAP      130
#define KW_MAPJOIN      131
#define KW_MATERIALIZED      132
#define KW_MINUS      133
#define KW_MSCK      134
#define KW_NOT      135
#define KW_NO_DROP      136
#define KW_NULL      137
#define KW_OF      138
#define KW_OFFLINE      139
#define KW_ON      140
#define KW_OPTION      141
#define KW_OR      142
#define KW_ORDER      143
#define KW_OUT      144
#define KW_OUTER      145
#define KW_OUTPUT      146
#define KW_OUTPUTDRIVER      147
#define KW_OUTPUTFORMAT      148
#define KW_OVERWRITE      149
#define KW_PARTITION      150
#define KW_PARTITIONED      151
#define KW_PARTITIONS      152
#define KW_PLUS      153
#define KW_PRESERVE      154
#define KW_PROCEDURE      155
#define KW_PURGE      156
#define KW_RANGE      157
#define KW_RCFILE      158
#define KW_READ      159
#define KW_READONLY      160
#define KW_READS      161
#define KW_REBUILD      162
#define KW_RECORDREADER      163
#define KW_RECORDWRITER      164
#define KW_REDUCE      165
#define KW_REGEXP      166
#define KW_RENAME      167
#define KW_REPAIR      168
#define KW_REPLACE      169
#define KW_REVOKE      170
#define KW_RIGHT      171
#define KW_RLIKE      172
#define KW_ROW      173
#define KW_SCHEMA      174
#define KW_SCHEMAS      175
#define KW_SELECT      176
#define KW_SEMI      177
#define KW_SEQUENCEFILE      178
#define KW_SERDE      179
#define KW_SERDEPROPERTIES      180
#define KW_SET      181
#define KW_SHARED      182
#define KW_SHOW      183
#define KW_SHOW_DATABASE      184
#define KW_SIZE      185
#define KW_SMALLINT      186
#define KW_SORT      187
#define KW_SORTED      188
#define KW_SSL      189
#define KW_STATISTICS      190
#define KW_STORED      191
#define KW_STREAM      192
#define KW_STREAMTABLE      193
#define KW_STRING      194
#define KW_STRUCT      195
#define KW_TABLE      196
#define KW_TABLES      197
#define KW_TABLESAMPLE      198
#define KW_TBLPROPERTIES      199
#define KW_TEMPORARY      200
#define KW_TERMINATED      201
#define KW_TEXTFILE      202
#define KW_THEN      203
#define KW_TIMESTAMP      204
#define KW_TINYINT      205
#define KW_TO      206
#define KW_TOUCH      207
#define KW_TRANSFORM      208
#define KW_TRIGGER      209
#define KW_TRUE      210
#define KW_UNARCHIVE      211
#define KW_UNDO      212
#define KW_UNION      213
#define KW_UNIONTYPE      214
#define KW_UNIQUEJOIN      215
#define KW_UNLOCK      216
#define KW_UNSIGNED      217
#define KW_UPDATE      218
#define KW_USE      219
#define KW_USING      220
#define KW_UTC      221
#define KW_UTCTIMESTAMP      222
#define KW_VALUE_TYPE      223
#define KW_VIEW      224
#define KW_WHEN      225
#define KW_WHERE      226
#define KW_WHILE      227
#define KW_WINDOW      228
#define KW_WITH      229
#define LCURLY      230
#define LESSTHAN      231
#define LESSTHANOREQUALTO      232
#define LPAREN      233
#define LSQUARE      234
#define Letter      235
#define MINUS      236
#define MOD      237
#define NOTEQUAL      238
#define Number      239
#define PLUS      240
#define QUESTION      241
#define RCURLY      242
#define RPAREN      243
#define RSQUARE      244
#define RegexComponent      245
#define SEMICOLON      246
#define STAR      247
#define StringLiteral      248
#define TILDE      249
#define TOK_CREATE_SCHEMA      250
#define TOK_CREATE_STREAM      251
#define TOK_CREATE_WINDOW      252
#define TOK_NAME_TYPE      253
#define TOK_SCHEMA_LIST      254
#define TOK_SELECT      255
#define TOK_SELEXPR      256
#define TOK_SELITEM      257
#define TOK_SELLIST      258
#define WS      259
#ifdef	EOF
#undef	EOF
#define	EOF	ANTLR3_TOKEN_EOF
#endif

#ifndef TOKENSOURCE
#define TOKENSOURCE(lxr) lxr->pLexer->rec->state->tokSource
#endif

/* End of token definitions for SQLParser
 * =============================================================================
 */
/** } */

#ifdef __cplusplus
}
#endif

#endif

/* END - Note:Keep extra line feed to satisfy UNIX systems */
