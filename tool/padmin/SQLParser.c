/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : SQL.g
 *     -                            On : 2011-10-10 18:39:49
 *     -                for the parser : SQLParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "SQLParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pSQLParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pSQLParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pSQLParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pSQLParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   SQLParserTokenNames[256+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "AMPERSAND",
        (pANTLR3_UINT8) "BITWISEOR",
        (pANTLR3_UINT8) "BITWISEXOR",
        (pANTLR3_UINT8) "COLON",
        (pANTLR3_UINT8) "COMMA",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "CharSetLiteral",
        (pANTLR3_UINT8) "CharSetName",
        (pANTLR3_UINT8) "DIV",
        (pANTLR3_UINT8) "DIVIDE",
        (pANTLR3_UINT8) "DOLLAR",
        (pANTLR3_UINT8) "DOT",
        (pANTLR3_UINT8) "Digit",
        (pANTLR3_UINT8) "EQUAL",
        (pANTLR3_UINT8) "Exponent",
        (pANTLR3_UINT8) "GREATERTHAN",
        (pANTLR3_UINT8) "GREATERTHANOREQUALTO",
        (pANTLR3_UINT8) "HexDigit",
        (pANTLR3_UINT8) "Identifier",
        (pANTLR3_UINT8) "KW_ADD",
        (pANTLR3_UINT8) "KW_ADVANCE",
        (pANTLR3_UINT8) "KW_AFTER",
        (pANTLR3_UINT8) "KW_ALL",
        (pANTLR3_UINT8) "KW_ALTER",
        (pANTLR3_UINT8) "KW_ANALYZE",
        (pANTLR3_UINT8) "KW_AND",
        (pANTLR3_UINT8) "KW_ARCHIVE",
        (pANTLR3_UINT8) "KW_ARRAY",
        (pANTLR3_UINT8) "KW_AS",
        (pANTLR3_UINT8) "KW_ASC",
        (pANTLR3_UINT8) "KW_BEFORE",
        (pANTLR3_UINT8) "KW_BETWEEN",
        (pANTLR3_UINT8) "KW_BIGINT",
        (pANTLR3_UINT8) "KW_BINARY",
        (pANTLR3_UINT8) "KW_BOOLEAN",
        (pANTLR3_UINT8) "KW_BOTH",
        (pANTLR3_UINT8) "KW_BUCKET",
        (pANTLR3_UINT8) "KW_BUCKETS",
        (pANTLR3_UINT8) "KW_BY",
        (pANTLR3_UINT8) "KW_CASE",
        (pANTLR3_UINT8) "KW_CAST",
        (pANTLR3_UINT8) "KW_CHANGE",
        (pANTLR3_UINT8) "KW_CLUSTER",
        (pANTLR3_UINT8) "KW_CLUSTERED",
        (pANTLR3_UINT8) "KW_CLUSTERSTATUS",
        (pANTLR3_UINT8) "KW_COLLECTION",
        (pANTLR3_UINT8) "KW_COLUMN",
        (pANTLR3_UINT8) "KW_COLUMNS",
        (pANTLR3_UINT8) "KW_COMMENT",
        (pANTLR3_UINT8) "KW_COMPUTE",
        (pANTLR3_UINT8) "KW_CONTINUE",
        (pANTLR3_UINT8) "KW_CREATE",
        (pANTLR3_UINT8) "KW_CROSS",
        (pANTLR3_UINT8) "KW_CURSOR",
        (pANTLR3_UINT8) "KW_DATA",
        (pANTLR3_UINT8) "KW_DATABASE",
        (pANTLR3_UINT8) "KW_DATABASES",
        (pANTLR3_UINT8) "KW_DATE",
        (pANTLR3_UINT8) "KW_DATETIME",
        (pANTLR3_UINT8) "KW_DBPROPERTIES",
        (pANTLR3_UINT8) "KW_DEFERRED",
        (pANTLR3_UINT8) "KW_DELETE",
        (pANTLR3_UINT8) "KW_DELIMITED",
        (pANTLR3_UINT8) "KW_DESC",
        (pANTLR3_UINT8) "KW_DESCRIBE",
        (pANTLR3_UINT8) "KW_DIRECTORY",
        (pANTLR3_UINT8) "KW_DISABLE",
        (pANTLR3_UINT8) "KW_DISTINCT",
        (pANTLR3_UINT8) "KW_DISTRIBUTE",
        (pANTLR3_UINT8) "KW_DOUBLE",
        (pANTLR3_UINT8) "KW_DROP",
        (pANTLR3_UINT8) "KW_ELEM_TYPE",
        (pANTLR3_UINT8) "KW_ELSE",
        (pANTLR3_UINT8) "KW_ENABLE",
        (pANTLR3_UINT8) "KW_END",
        (pANTLR3_UINT8) "KW_ESCAPED",
        (pANTLR3_UINT8) "KW_EXCLUSIVE",
        (pANTLR3_UINT8) "KW_EXISTS",
        (pANTLR3_UINT8) "KW_EXPLAIN",
        (pANTLR3_UINT8) "KW_EXTENDED",
        (pANTLR3_UINT8) "KW_EXTERNAL",
        (pANTLR3_UINT8) "KW_FALSE",
        (pANTLR3_UINT8) "KW_FETCH",
        (pANTLR3_UINT8) "KW_FIELDS",
        (pANTLR3_UINT8) "KW_FILEFORMAT",
        (pANTLR3_UINT8) "KW_FIRST",
        (pANTLR3_UINT8) "KW_FLOAT",
        (pANTLR3_UINT8) "KW_FORMAT",
        (pANTLR3_UINT8) "KW_FORMATTED",
        (pANTLR3_UINT8) "KW_FROM",
        (pANTLR3_UINT8) "KW_FULL",
        (pANTLR3_UINT8) "KW_FUNCTION",
        (pANTLR3_UINT8) "KW_FUNCTIONS",
        (pANTLR3_UINT8) "KW_GRANT",
        (pANTLR3_UINT8) "KW_GROUP",
        (pANTLR3_UINT8) "KW_HAVING",
        (pANTLR3_UINT8) "KW_HOLD_DDLTIME",
        (pANTLR3_UINT8) "KW_IDXPROPERTIES",
        (pANTLR3_UINT8) "KW_IF",
        (pANTLR3_UINT8) "KW_IN",
        (pANTLR3_UINT8) "KW_INDEX",
        (pANTLR3_UINT8) "KW_INDEXES",
        (pANTLR3_UINT8) "KW_INPATH",
        (pANTLR3_UINT8) "KW_INPUT",
        (pANTLR3_UINT8) "KW_INPUTDRIVER",
        (pANTLR3_UINT8) "KW_INPUTFORMAT",
        (pANTLR3_UINT8) "KW_INSERT",
        (pANTLR3_UINT8) "KW_INT",
        (pANTLR3_UINT8) "KW_INTERSECT",
        (pANTLR3_UINT8) "KW_INTO",
        (pANTLR3_UINT8) "KW_IS",
        (pANTLR3_UINT8) "KW_ITEMS",
        (pANTLR3_UINT8) "KW_JOIN",
        (pANTLR3_UINT8) "KW_KEYS",
        (pANTLR3_UINT8) "KW_KEY_TYPE",
        (pANTLR3_UINT8) "KW_LATERAL",
        (pANTLR3_UINT8) "KW_LEFT",
        (pANTLR3_UINT8) "KW_LIKE",
        (pANTLR3_UINT8) "KW_LIMIT",
        (pANTLR3_UINT8) "KW_LINES",
        (pANTLR3_UINT8) "KW_LOAD",
        (pANTLR3_UINT8) "KW_LOCAL",
        (pANTLR3_UINT8) "KW_LOCATION",
        (pANTLR3_UINT8) "KW_LOCK",
        (pANTLR3_UINT8) "KW_LOCKS",
        (pANTLR3_UINT8) "KW_LONG",
        (pANTLR3_UINT8) "KW_MAP",
        (pANTLR3_UINT8) "KW_MAPJOIN",
        (pANTLR3_UINT8) "KW_MATERIALIZED",
        (pANTLR3_UINT8) "KW_MINUS",
        (pANTLR3_UINT8) "KW_MSCK",
        (pANTLR3_UINT8) "KW_NOT",
        (pANTLR3_UINT8) "KW_NO_DROP",
        (pANTLR3_UINT8) "KW_NULL",
        (pANTLR3_UINT8) "KW_OF",
        (pANTLR3_UINT8) "KW_OFFLINE",
        (pANTLR3_UINT8) "KW_ON",
        (pANTLR3_UINT8) "KW_OPTION",
        (pANTLR3_UINT8) "KW_OR",
        (pANTLR3_UINT8) "KW_ORDER",
        (pANTLR3_UINT8) "KW_OUT",
        (pANTLR3_UINT8) "KW_OUTER",
        (pANTLR3_UINT8) "KW_OUTPUT",
        (pANTLR3_UINT8) "KW_OUTPUTDRIVER",
        (pANTLR3_UINT8) "KW_OUTPUTFORMAT",
        (pANTLR3_UINT8) "KW_OVERWRITE",
        (pANTLR3_UINT8) "KW_PARTITION",
        (pANTLR3_UINT8) "KW_PARTITIONED",
        (pANTLR3_UINT8) "KW_PARTITIONS",
        (pANTLR3_UINT8) "KW_PLUS",
        (pANTLR3_UINT8) "KW_PRESERVE",
        (pANTLR3_UINT8) "KW_PROCEDURE",
        (pANTLR3_UINT8) "KW_PURGE",
        (pANTLR3_UINT8) "KW_RANGE",
        (pANTLR3_UINT8) "KW_RCFILE",
        (pANTLR3_UINT8) "KW_READ",
        (pANTLR3_UINT8) "KW_READONLY",
        (pANTLR3_UINT8) "KW_READS",
        (pANTLR3_UINT8) "KW_REBUILD",
        (pANTLR3_UINT8) "KW_RECORDREADER",
        (pANTLR3_UINT8) "KW_RECORDWRITER",
        (pANTLR3_UINT8) "KW_REDUCE",
        (pANTLR3_UINT8) "KW_REGEXP",
        (pANTLR3_UINT8) "KW_RENAME",
        (pANTLR3_UINT8) "KW_REPAIR",
        (pANTLR3_UINT8) "KW_REPLACE",
        (pANTLR3_UINT8) "KW_REVOKE",
        (pANTLR3_UINT8) "KW_RIGHT",
        (pANTLR3_UINT8) "KW_RLIKE",
        (pANTLR3_UINT8) "KW_ROW",
        (pANTLR3_UINT8) "KW_SCHEMA",
        (pANTLR3_UINT8) "KW_SCHEMAS",
        (pANTLR3_UINT8) "KW_SELECT",
        (pANTLR3_UINT8) "KW_SEMI",
        (pANTLR3_UINT8) "KW_SEQUENCEFILE",
        (pANTLR3_UINT8) "KW_SERDE",
        (pANTLR3_UINT8) "KW_SERDEPROPERTIES",
        (pANTLR3_UINT8) "KW_SET",
        (pANTLR3_UINT8) "KW_SHARED",
        (pANTLR3_UINT8) "KW_SHOW",
        (pANTLR3_UINT8) "KW_SHOW_DATABASE",
        (pANTLR3_UINT8) "KW_SIZE",
        (pANTLR3_UINT8) "KW_SMALLINT",
        (pANTLR3_UINT8) "KW_SORT",
        (pANTLR3_UINT8) "KW_SORTED",
        (pANTLR3_UINT8) "KW_SSL",
        (pANTLR3_UINT8) "KW_STATISTICS",
        (pANTLR3_UINT8) "KW_STORED",
        (pANTLR3_UINT8) "KW_STREAM",
        (pANTLR3_UINT8) "KW_STREAMTABLE",
        (pANTLR3_UINT8) "KW_STRING",
        (pANTLR3_UINT8) "KW_STRUCT",
        (pANTLR3_UINT8) "KW_TABLE",
        (pANTLR3_UINT8) "KW_TABLES",
        (pANTLR3_UINT8) "KW_TABLESAMPLE",
        (pANTLR3_UINT8) "KW_TBLPROPERTIES",
        (pANTLR3_UINT8) "KW_TEMPORARY",
        (pANTLR3_UINT8) "KW_TERMINATED",
        (pANTLR3_UINT8) "KW_TEXTFILE",
        (pANTLR3_UINT8) "KW_THEN",
        (pANTLR3_UINT8) "KW_TIMESTAMP",
        (pANTLR3_UINT8) "KW_TINYINT",
        (pANTLR3_UINT8) "KW_TO",
        (pANTLR3_UINT8) "KW_TOUCH",
        (pANTLR3_UINT8) "KW_TRANSFORM",
        (pANTLR3_UINT8) "KW_TRIGGER",
        (pANTLR3_UINT8) "KW_TRUE",
        (pANTLR3_UINT8) "KW_UNARCHIVE",
        (pANTLR3_UINT8) "KW_UNDO",
        (pANTLR3_UINT8) "KW_UNION",
        (pANTLR3_UINT8) "KW_UNIONTYPE",
        (pANTLR3_UINT8) "KW_UNIQUEJOIN",
        (pANTLR3_UINT8) "KW_UNLOCK",
        (pANTLR3_UINT8) "KW_UNSIGNED",
        (pANTLR3_UINT8) "KW_UPDATE",
        (pANTLR3_UINT8) "KW_USE",
        (pANTLR3_UINT8) "KW_USING",
        (pANTLR3_UINT8) "KW_UTC",
        (pANTLR3_UINT8) "KW_UTCTIMESTAMP",
        (pANTLR3_UINT8) "KW_VALUE_TYPE",
        (pANTLR3_UINT8) "KW_VIEW",
        (pANTLR3_UINT8) "KW_WHEN",
        (pANTLR3_UINT8) "KW_WHERE",
        (pANTLR3_UINT8) "KW_WHILE",
        (pANTLR3_UINT8) "KW_WINDOW",
        (pANTLR3_UINT8) "KW_WITH",
        (pANTLR3_UINT8) "LCURLY",
        (pANTLR3_UINT8) "LESSTHAN",
        (pANTLR3_UINT8) "LESSTHANOREQUALTO",
        (pANTLR3_UINT8) "LPAREN",
        (pANTLR3_UINT8) "LSQUARE",
        (pANTLR3_UINT8) "Letter",
        (pANTLR3_UINT8) "MINUS",
        (pANTLR3_UINT8) "MOD",
        (pANTLR3_UINT8) "NOTEQUAL",
        (pANTLR3_UINT8) "Number",
        (pANTLR3_UINT8) "PLUS",
        (pANTLR3_UINT8) "QUESTION",
        (pANTLR3_UINT8) "RCURLY",
        (pANTLR3_UINT8) "RPAREN",
        (pANTLR3_UINT8) "RSQUARE",
        (pANTLR3_UINT8) "RegexComponent",
        (pANTLR3_UINT8) "SEMICOLON",
        (pANTLR3_UINT8) "STAR",
        (pANTLR3_UINT8) "StringLiteral",
        (pANTLR3_UINT8) "TILDE",
        (pANTLR3_UINT8) "TOK_CREATE_SCHEMA",
        (pANTLR3_UINT8) "TOK_CREATE_STREAM",
        (pANTLR3_UINT8) "TOK_CREATE_WINDOW",
        (pANTLR3_UINT8) "TOK_NAME_TYPE",
        (pANTLR3_UINT8) "TOK_SCHEMA_LIST",
        (pANTLR3_UINT8) "TOK_SELECT",
        (pANTLR3_UINT8) "TOK_SELEXPR",
        (pANTLR3_UINT8) "TOK_SELITEM",
        (pANTLR3_UINT8) "TOK_SELLIST",
        (pANTLR3_UINT8) "WS"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 SQLParser_statement_return
	statement    (pSQLParser ctx);
static 
 SQLParser_selectStatement_return
	selectStatement    (pSQLParser ctx);
static 
 SQLParser_selectList_return
	selectList    (pSQLParser ctx);
static 
 SQLParser_selectColumn_return
	selectColumn    (pSQLParser ctx);
static 
 SQLParser_selectItem_return
	selectItem    (pSQLParser ctx);
static 
 SQLParser_selectExpression_return
	selectExpression    (pSQLParser ctx);
static 
 SQLParser_createStatement_return
	createStatement    (pSQLParser ctx);
static 
 SQLParser_schemaList_return
	schemaList    (pSQLParser ctx);
static 
 SQLParser_streamType_return
	streamType    (pSQLParser ctx);
static 
 SQLParser_columnNameType_return
	columnNameType    (pSQLParser ctx);
static 
 SQLParser_dataType_return
	dataType    (pSQLParser ctx);
static void	SQLParserFree(pSQLParser ctx);
static void     SQLParserReset (pSQLParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
/* static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}
*/
/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "SQL.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new SQLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pSQLParser
SQLParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return SQLParserNewSSD(instream, NULL);
}

/** \brief Create a new SQLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pSQLParser
SQLParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pSQLParser ctx;	    /* Context structure we will build and return   */

    ctx	= (pSQLParser) ANTLR3_CALLOC(1, sizeof(SQLParser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in SQLParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our SQLParser interface
     */
    ctx->statement	= statement;
    ctx->selectStatement	= selectStatement;
    ctx->selectList	= selectList;
    ctx->selectColumn	= selectColumn;
    ctx->selectItem	= selectItem;
    ctx->selectExpression	= selectExpression;
    ctx->createStatement	= createStatement;
    ctx->schemaList	= schemaList;
    ctx->streamType	= streamType;
    ctx->columnNameType	= columnNameType;
    ctx->dataType	= dataType;
    ctx->free			= SQLParserFree;
    ctx->reset			= SQLParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */
ADAPTOR	= ANTLR3_TREE_ADAPTORNew(instream->tstream->tokenSource->strFactory);

ctx->vectors	= antlr3VectorFactoryNew(0);
    /* Install the token table
     */
    PSRSTATE->tokenNames   = SQLParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
SQLParserReset (pSQLParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 SQLParserFree(pSQLParser ctx)
 {
    /* Free any scope memory
     */

ctx->vectors->close(ctx->vectors);
/* We created the adaptor so we must free it
 */
ADAPTOR->free(ADAPTOR);
	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
/*static pANTLR3_UINT8    *getTokenNames()
{
        return SQLParserTokenNames;
}*/


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_selectStatement_in_statement89  */
static	ANTLR3_BITWORD FOLLOW_selectStatement_in_statement89_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_selectStatement_in_statement89	= { FOLLOW_selectStatement_in_statement89_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_statement91  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_statement91_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_statement91	= { FOLLOW_EOF_in_statement91_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_createStatement_in_statement96  */
static	ANTLR3_BITWORD FOLLOW_createStatement_in_statement96_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_createStatement_in_statement96	= { FOLLOW_createStatement_in_statement96_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_statement98  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_statement98_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_statement98	= { FOLLOW_EOF_in_statement98_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_SELECT_in_selectStatement110  */
static	ANTLR3_BITWORD FOLLOW_KW_SELECT_in_selectStatement110_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_SELECT_in_selectStatement110	= { FOLLOW_KW_SELECT_in_selectStatement110_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_selectList_in_selectStatement112  */
static	ANTLR3_BITWORD FOLLOW_selectList_in_selectStatement112_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_selectList_in_selectStatement112	= { FOLLOW_selectList_in_selectStatement112_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_FROM_in_selectStatement116  */
static	ANTLR3_BITWORD FOLLOW_KW_FROM_in_selectStatement116_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_FROM_in_selectStatement116	= { FOLLOW_KW_FROM_in_selectStatement116_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_selectStatement120  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_selectStatement120_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000040000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_selectStatement120	= { FOLLOW_Identifier_in_selectStatement120_bits, 4	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LSQUARE_in_selectStatement122  */
static	ANTLR3_BITWORD FOLLOW_LSQUARE_in_selectStatement122_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_LSQUARE_in_selectStatement122	= { FOLLOW_LSQUARE_in_selectStatement122_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_selectStatement126  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_selectStatement126_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_selectStatement126	= { FOLLOW_Identifier_in_selectStatement126_bits, 4	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RSQUARE_in_selectStatement128  */
static	ANTLR3_BITWORD FOLLOW_RSQUARE_in_selectStatement128_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0002000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RSQUARE_in_selectStatement128	= { FOLLOW_RSQUARE_in_selectStatement128_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_INTO_in_selectStatement130  */
static	ANTLR3_BITWORD FOLLOW_KW_INTO_in_selectStatement130_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_INTO_in_selectStatement130	= { FOLLOW_KW_INTO_in_selectStatement130_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_selectStatement134  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_selectStatement134_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_selectStatement134	= { FOLLOW_Identifier_in_selectStatement134_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_selectColumn_in_selectList164  */
static	ANTLR3_BITWORD FOLLOW_selectColumn_in_selectList164_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_selectColumn_in_selectList164	= { FOLLOW_selectColumn_in_selectList164_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_selectList167  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_selectList167_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_selectList167	= { FOLLOW_COMMA_in_selectList167_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_selectColumn_in_selectList169  */
static	ANTLR3_BITWORD FOLLOW_selectColumn_in_selectList169_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_selectColumn_in_selectList169	= { FOLLOW_selectColumn_in_selectList169_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_selectItem_in_selectColumn193  */
static	ANTLR3_BITWORD FOLLOW_selectItem_in_selectColumn193_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_selectItem_in_selectColumn193	= { FOLLOW_selectItem_in_selectColumn193_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_selectExpression_in_selectColumn199  */
static	ANTLR3_BITWORD FOLLOW_selectExpression_in_selectColumn199_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_selectExpression_in_selectColumn199	= { FOLLOW_selectExpression_in_selectColumn199_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_selectItem214  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_selectItem214_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_selectItem214	= { FOLLOW_Identifier_in_selectItem214_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_AS_in_selectItem216  */
static	ANTLR3_BITWORD FOLLOW_KW_AS_in_selectItem216_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_AS_in_selectItem216	= { FOLLOW_KW_AS_in_selectItem216_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_selectItem218  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_selectItem218_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_selectItem218	= { FOLLOW_Identifier_in_selectItem218_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_selectExpression249  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_selectExpression249_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_selectExpression249	= { FOLLOW_Identifier_in_selectExpression249_bits, 4	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_selectExpression251  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_selectExpression251_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_selectExpression251	= { FOLLOW_LPAREN_in_selectExpression251_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_selectExpression255  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_selectExpression255_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0008000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_selectExpression255	= { FOLLOW_Identifier_in_selectExpression255_bits, 4	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_selectExpression257  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_selectExpression257_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_selectExpression257	= { FOLLOW_RPAREN_in_selectExpression257_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_AS_in_selectExpression259  */
static	ANTLR3_BITWORD FOLLOW_KW_AS_in_selectExpression259_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_AS_in_selectExpression259	= { FOLLOW_KW_AS_in_selectExpression259_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_selectExpression263  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_selectExpression263_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_selectExpression263	= { FOLLOW_Identifier_in_selectExpression263_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_CREATE_in_createStatement291  */
static	ANTLR3_BITWORD FOLLOW_KW_CREATE_in_createStatement291_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000400000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_CREATE_in_createStatement291	= { FOLLOW_KW_CREATE_in_createStatement291_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_SCHEMA_in_createStatement293  */
static	ANTLR3_BITWORD FOLLOW_KW_SCHEMA_in_createStatement293_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_SCHEMA_in_createStatement293	= { FOLLOW_KW_SCHEMA_in_createStatement293_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_createStatement295  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_createStatement295_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_createStatement295	= { FOLLOW_Identifier_in_createStatement295_bits, 4	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_schemaList_in_createStatement297  */
static	ANTLR3_BITWORD FOLLOW_schemaList_in_createStatement297_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_schemaList_in_createStatement297	= { FOLLOW_schemaList_in_createStatement297_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_CREATE_in_createStatement316  */
static	ANTLR3_BITWORD FOLLOW_KW_CREATE_in_createStatement316_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000080000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_CREATE_in_createStatement316	= { FOLLOW_KW_CREATE_in_createStatement316_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_streamType_in_createStatement318  */
static	ANTLR3_BITWORD FOLLOW_streamType_in_createStatement318_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_streamType_in_createStatement318	= { FOLLOW_streamType_in_createStatement318_bits, 4	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_STREAM_in_createStatement320  */
static	ANTLR3_BITWORD FOLLOW_KW_STREAM_in_createStatement320_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_STREAM_in_createStatement320	= { FOLLOW_KW_STREAM_in_createStatement320_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_createStatement324  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_createStatement324_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_createStatement324	= { FOLLOW_Identifier_in_createStatement324_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_createStatement328  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_createStatement328_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_createStatement328	= { FOLLOW_Identifier_in_createStatement328_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_CREATE_in_createStatement349  */
static	ANTLR3_BITWORD FOLLOW_KW_CREATE_in_createStatement349_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_CREATE_in_createStatement349	= { FOLLOW_KW_CREATE_in_createStatement349_bits, 4	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_WINDOW_in_createStatement351  */
static	ANTLR3_BITWORD FOLLOW_KW_WINDOW_in_createStatement351_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_WINDOW_in_createStatement351	= { FOLLOW_KW_WINDOW_in_createStatement351_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_createStatement358  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_createStatement358_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_createStatement358	= { FOLLOW_Identifier_in_createStatement358_bits, 4	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_createStatement360  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_createStatement360_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0200000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_createStatement360	= { FOLLOW_LPAREN_in_createStatement360_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_SIZE_in_createStatement362  */
static	ANTLR3_BITWORD FOLLOW_KW_SIZE_in_createStatement362_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_SIZE_in_createStatement362	= { FOLLOW_KW_SIZE_in_createStatement362_bits, 4	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Number_in_createStatement364  */
static	ANTLR3_BITWORD FOLLOW_Number_in_createStatement364_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Number_in_createStatement364	= { FOLLOW_Number_in_createStatement364_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_ADVANCE_in_createStatement366  */
static	ANTLR3_BITWORD FOLLOW_KW_ADVANCE_in_createStatement366_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_ADVANCE_in_createStatement366	= { FOLLOW_KW_ADVANCE_in_createStatement366_bits, 4	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Number_in_createStatement368  */
static	ANTLR3_BITWORD FOLLOW_Number_in_createStatement368_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_Number_in_createStatement368	= { FOLLOW_Number_in_createStatement368_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_ON_in_createStatement370  */
static	ANTLR3_BITWORD FOLLOW_KW_ON_in_createStatement370_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_ON_in_createStatement370	= { FOLLOW_KW_ON_in_createStatement370_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_createStatement374  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_createStatement374_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0008000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_createStatement374	= { FOLLOW_Identifier_in_createStatement374_bits, 4	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_createStatement376  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_createStatement376_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_createStatement376	= { FOLLOW_RPAREN_in_createStatement376_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_schemaList405  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_schemaList405_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_schemaList405	= { FOLLOW_LPAREN_in_schemaList405_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_columnNameType_in_schemaList407  */
static	ANTLR3_BITWORD FOLLOW_columnNameType_in_schemaList407_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0008000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_columnNameType_in_schemaList407	= { FOLLOW_columnNameType_in_schemaList407_bits, 4	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_schemaList410  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_schemaList410_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_schemaList410	= { FOLLOW_COMMA_in_schemaList410_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_columnNameType_in_schemaList412  */
static	ANTLR3_BITWORD FOLLOW_columnNameType_in_schemaList412_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0008000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_columnNameType_in_schemaList412	= { FOLLOW_columnNameType_in_schemaList412_bits, 4	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_schemaList416  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_schemaList416_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_schemaList416	= { FOLLOW_RPAREN_in_schemaList416_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_columnNameType458  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_columnNameType458_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_columnNameType458	= { FOLLOW_Identifier_in_columnNameType458_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dataType_in_columnNameType460  */
static	ANTLR3_BITWORD FOLLOW_dataType_in_columnNameType460_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dataType_in_columnNameType460	= { FOLLOW_dataType_in_columnNameType460_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start statement
 * SQL.g:23:1: statement : ( selectStatement EOF | createStatement EOF );
 */
static SQLParser_statement_return
statement(pSQLParser ctx)
{
    SQLParser_statement_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EOF2;
    pANTLR3_COMMON_TOKEN    EOF4;
    SQLParser_selectStatement_return selectStatement1;
    #undef	RETURN_TYPE_selectStatement1
    #define	RETURN_TYPE_selectStatement1 SQLParser_selectStatement_return

    SQLParser_createStatement_return createStatement3;
    #undef	RETURN_TYPE_createStatement3
    #define	RETURN_TYPE_createStatement3 SQLParser_createStatement_return

    pANTLR3_BASE_TREE EOF2_tree;
    pANTLR3_BASE_TREE EOF4_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    EOF2       = NULL;
    EOF4       = NULL;
    selectStatement1.tree = NULL;

    createStatement3.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EOF2_tree   = NULL;
    EOF4_tree   = NULL;


    retval.tree  = NULL;

    {
        {
            //  SQL.g:24:2: ( selectStatement EOF | createStatement EOF )

            ANTLR3_UINT32 alt1;

            alt1=2;

            switch ( LA(1) )
            {
            case KW_SELECT:
            	{
            		alt1=1;
            	}
                break;
            case KW_CREATE:
            	{
            		alt1=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 1;
                EXCEPTION->state        = 0;


                goto rulestatementEx;

            }

            switch (alt1)
            {
        	case 1:
        	    // SQL.g:24:4: selectStatement EOF
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_selectStatement_in_statement89);
        	        selectStatement1=selectStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, selectStatement1.tree);

        	        EOF2 = (pANTLR3_COMMON_TOKEN) MATCHT(EOF, &FOLLOW_EOF_in_statement91);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }

        	        EOF2_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EOF2));
        	        ADAPTOR->addChild(ADAPTOR, root_0, EOF2_tree);


        	    }
        	    break;
        	case 2:
        	    // SQL.g:25:4: createStatement EOF
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_createStatement_in_statement96);
        	        createStatement3=createStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, createStatement3.tree);

        	        EOF4 = (pANTLR3_COMMON_TOKEN) MATCHT(EOF, &FOLLOW_EOF_in_statement98);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }

        	        EOF4_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EOF4));
        	        ADAPTOR->addChild(ADAPTOR, root_0, EOF4_tree);


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end statement */

/**
 * $ANTLR start selectStatement
 * SQL.g:28:1: selectStatement : KW_SELECT selectList KW_FROM instreamName= Identifier LSQUARE windowName= Identifier RSQUARE KW_INTO outstreamName= Identifier -> ^( KW_SELECT selectList $instreamName $windowName $outstreamName) ;
 */
static SQLParser_selectStatement_return
selectStatement(pSQLParser ctx)
{
    SQLParser_selectStatement_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    instreamName;
    pANTLR3_COMMON_TOKEN    windowName;
    pANTLR3_COMMON_TOKEN    outstreamName;
    pANTLR3_COMMON_TOKEN    KW_SELECT5;
    pANTLR3_COMMON_TOKEN    KW_FROM7;
    pANTLR3_COMMON_TOKEN    LSQUARE8;
    pANTLR3_COMMON_TOKEN    RSQUARE9;
    pANTLR3_COMMON_TOKEN    KW_INTO10;
    SQLParser_selectList_return selectList6;
    #undef	RETURN_TYPE_selectList6
    #define	RETURN_TYPE_selectList6 SQLParser_selectList_return

    pANTLR3_BASE_TREE instreamName_tree;
    pANTLR3_BASE_TREE windowName_tree;
    pANTLR3_BASE_TREE outstreamName_tree;
    pANTLR3_BASE_TREE KW_SELECT5_tree;
    pANTLR3_BASE_TREE KW_FROM7_tree;
    pANTLR3_BASE_TREE LSQUARE8_tree;
    pANTLR3_BASE_TREE RSQUARE9_tree;
    pANTLR3_BASE_TREE KW_INTO10_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_SELECT;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_LSQUARE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_INTO;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_RSQUARE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_Identifier;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_FROM;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_selectList;
    /* Initialize rule variables
     */

    root_0 = NULL;

    instreamName       = NULL;
    windowName       = NULL;
    outstreamName       = NULL;
    KW_SELECT5       = NULL;
    KW_FROM7       = NULL;
    LSQUARE8       = NULL;
    RSQUARE9       = NULL;
    KW_INTO10       = NULL;
    selectList6.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    instreamName_tree   = NULL;
    windowName_tree   = NULL;
    outstreamName_tree   = NULL;
    KW_SELECT5_tree   = NULL;
    KW_FROM7_tree   = NULL;
    LSQUARE8_tree   = NULL;
    RSQUARE9_tree   = NULL;
    KW_INTO10_tree   = NULL;

    stream_KW_SELECT   = NULL;
    #define CREATE_stream_KW_SELECT  if (stream_KW_SELECT == NULL) {stream_KW_SELECT = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_SELECT"); } 
    stream_LSQUARE   = NULL;
    #define CREATE_stream_LSQUARE  if (stream_LSQUARE == NULL) {stream_LSQUARE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token LSQUARE"); } 
    stream_KW_INTO   = NULL;
    #define CREATE_stream_KW_INTO  if (stream_KW_INTO == NULL) {stream_KW_INTO = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_INTO"); } 
    stream_RSQUARE   = NULL;
    #define CREATE_stream_RSQUARE  if (stream_RSQUARE == NULL) {stream_RSQUARE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token RSQUARE"); } 
    stream_Identifier   = NULL;
    #define CREATE_stream_Identifier  if (stream_Identifier == NULL) {stream_Identifier = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token Identifier"); } 
    stream_KW_FROM   = NULL;
    #define CREATE_stream_KW_FROM  if (stream_KW_FROM == NULL) {stream_KW_FROM = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_FROM"); } 
    stream_selectList   = NULL;
    #define CREATE_stream_selectList  if (stream_selectList == NULL) {stream_selectList = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule selectList"); }

    retval.tree  = NULL;

    {
        // SQL.g:29:2: ( KW_SELECT selectList KW_FROM instreamName= Identifier LSQUARE windowName= Identifier RSQUARE KW_INTO outstreamName= Identifier -> ^( KW_SELECT selectList $instreamName $windowName $outstreamName) )
        // SQL.g:29:4: KW_SELECT selectList KW_FROM instreamName= Identifier LSQUARE windowName= Identifier RSQUARE KW_INTO outstreamName= Identifier
        {
            KW_SELECT5 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_SELECT, &FOLLOW_KW_SELECT_in_selectStatement110);
            if  (HASEXCEPTION())
            {
                goto ruleselectStatementEx;
            }
             
            CREATE_stream_KW_SELECT; stream_KW_SELECT->add(stream_KW_SELECT, KW_SELECT5, NULL);


            FOLLOWPUSH(FOLLOW_selectList_in_selectStatement112);
            selectList6=selectList(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleselectStatementEx;
            }

            CREATE_stream_selectList; stream_selectList->add(stream_selectList, selectList6.tree, NULL);

            KW_FROM7 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_FROM, &FOLLOW_KW_FROM_in_selectStatement116);
            if  (HASEXCEPTION())
            {
                goto ruleselectStatementEx;
            }
             
            CREATE_stream_KW_FROM; stream_KW_FROM->add(stream_KW_FROM, KW_FROM7, NULL);


            instreamName = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_selectStatement120);
            if  (HASEXCEPTION())
            {
                goto ruleselectStatementEx;
            }
             
            CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, instreamName, NULL);


            LSQUARE8 = (pANTLR3_COMMON_TOKEN) MATCHT(LSQUARE, &FOLLOW_LSQUARE_in_selectStatement122);
            if  (HASEXCEPTION())
            {
                goto ruleselectStatementEx;
            }
             
            CREATE_stream_LSQUARE; stream_LSQUARE->add(stream_LSQUARE, LSQUARE8, NULL);


            windowName = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_selectStatement126);
            if  (HASEXCEPTION())
            {
                goto ruleselectStatementEx;
            }
             
            CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, windowName, NULL);


            RSQUARE9 = (pANTLR3_COMMON_TOKEN) MATCHT(RSQUARE, &FOLLOW_RSQUARE_in_selectStatement128);
            if  (HASEXCEPTION())
            {
                goto ruleselectStatementEx;
            }
             
            CREATE_stream_RSQUARE; stream_RSQUARE->add(stream_RSQUARE, RSQUARE9, NULL);


            KW_INTO10 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_INTO, &FOLLOW_KW_INTO_in_selectStatement130);
            if  (HASEXCEPTION())
            {
                goto ruleselectStatementEx;
            }
             
            CREATE_stream_KW_INTO; stream_KW_INTO->add(stream_KW_INTO, KW_INTO10, NULL);


            outstreamName = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_selectStatement134);
            if  (HASEXCEPTION())
            {
                goto ruleselectStatementEx;
            }
             
            CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, outstreamName, NULL);


            /* AST REWRITE
             * elements          : outstreamName, KW_SELECT, instreamName, selectList, windowName
             * token labels      : windowName, instreamName, outstreamName
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_windowName;
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_instreamName;
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_outstreamName;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_windowName=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token windowName", windowName);
            	stream_instreamName=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token instreamName", instreamName);
            	stream_outstreamName=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token outstreamName", outstreamName);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 31:3: -> ^( KW_SELECT selectList $instreamName $windowName $outstreamName)
            	{
            	    // SQL.g:31:6: ^( KW_SELECT selectList $instreamName $windowName $outstreamName)
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        stream_KW_SELECT == NULL ? NULL : stream_KW_SELECT->nextNode(stream_KW_SELECT)
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_selectList == NULL ? NULL : stream_selectList->nextTree(stream_selectList));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_instreamName == NULL ? NULL : stream_instreamName->nextNode(stream_instreamName));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_windowName == NULL ? NULL : stream_windowName->nextNode(stream_windowName));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_outstreamName == NULL ? NULL : stream_outstreamName->nextNode(stream_outstreamName));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_windowName != NULL) stream_windowName->free(stream_windowName); 
            	if (stream_instreamName != NULL) stream_instreamName->free(stream_instreamName); 
            	if (stream_outstreamName != NULL) stream_outstreamName->free(stream_outstreamName); 
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleselectStatementEx; /* Prevent compiler warnings */
    ruleselectStatementEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_KW_SELECT != NULL) stream_KW_SELECT->free(stream_KW_SELECT);
        if (stream_LSQUARE != NULL) stream_LSQUARE->free(stream_LSQUARE);
        if (stream_KW_INTO != NULL) stream_KW_INTO->free(stream_KW_INTO);
        if (stream_RSQUARE != NULL) stream_RSQUARE->free(stream_RSQUARE);
        if (stream_Identifier != NULL) stream_Identifier->free(stream_Identifier);
        if (stream_KW_FROM != NULL) stream_KW_FROM->free(stream_KW_FROM);
        if (stream_selectList != NULL) stream_selectList->free(stream_selectList);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end selectStatement */

/**
 * $ANTLR start selectList
 * SQL.g:34:1: selectList : selectColumn ( COMMA selectColumn )* -> ^( TOK_SELLIST ( selectColumn )+ ) ;
 */
static SQLParser_selectList_return
selectList(pSQLParser ctx)
{
    SQLParser_selectList_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COMMA12;
    SQLParser_selectColumn_return selectColumn11;
    #undef	RETURN_TYPE_selectColumn11
    #define	RETURN_TYPE_selectColumn11 SQLParser_selectColumn_return

    SQLParser_selectColumn_return selectColumn13;
    #undef	RETURN_TYPE_selectColumn13
    #define	RETURN_TYPE_selectColumn13 SQLParser_selectColumn_return

    pANTLR3_BASE_TREE COMMA12_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_COMMA;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_selectColumn;
    /* Initialize rule variables
     */

    root_0 = NULL;

    COMMA12       = NULL;
    selectColumn11.tree = NULL;

    selectColumn13.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    COMMA12_tree   = NULL;

    stream_COMMA   = NULL;
    #define CREATE_stream_COMMA  if (stream_COMMA == NULL) {stream_COMMA = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token COMMA"); } 
    stream_selectColumn   = NULL;
    #define CREATE_stream_selectColumn  if (stream_selectColumn == NULL) {stream_selectColumn = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule selectColumn"); }

    retval.tree  = NULL;

    {
        // SQL.g:35:2: ( selectColumn ( COMMA selectColumn )* -> ^( TOK_SELLIST ( selectColumn )+ ) )
        // SQL.g:35:4: selectColumn ( COMMA selectColumn )*
        {
            FOLLOWPUSH(FOLLOW_selectColumn_in_selectList164);
            selectColumn11=selectColumn(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleselectListEx;
            }

            CREATE_stream_selectColumn; stream_selectColumn->add(stream_selectColumn, selectColumn11.tree, NULL);

            // SQL.g:35:17: ( COMMA selectColumn )*

            for (;;)
            {
                int alt2=2;
                switch ( LA(1) )
                {
                case COMMA:
                	{
                		alt2=1;
                	}
                    break;

                }

                switch (alt2)
                {
            	case 1:
            	    // SQL.g:35:18: COMMA selectColumn
            	    {
            	        COMMA12 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_selectList167);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleselectListEx;
            	        }
            	         
            	        CREATE_stream_COMMA; stream_COMMA->add(stream_COMMA, COMMA12, NULL);


            	        FOLLOWPUSH(FOLLOW_selectColumn_in_selectList169);
            	        selectColumn13=selectColumn(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleselectListEx;
            	        }

            	        CREATE_stream_selectColumn; stream_selectColumn->add(stream_selectColumn, selectColumn13.tree, NULL);

            	    }
            	    break;

            	default:
            	    goto loop2;	/* break out of the loop */
            	    break;
                }
            }
            loop2: ; /* Jump out to here if this rule does not match */


            /* AST REWRITE
             * elements          : selectColumn
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 36:3: -> ^( TOK_SELLIST ( selectColumn )+ )
            	{
            	    // SQL.g:36:6: ^( TOK_SELLIST ( selectColumn )+ )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TOK_SELLIST, (pANTLR3_UINT8)"TOK_SELLIST")
            	        , root_1));

            	        if ((stream_selectColumn == NULL || !stream_selectColumn->hasNext(stream_selectColumn))  )
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_REWRITE_EARLY_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_REWRITE_EARLY_EXCEPTION_NAME;
            	        }
            	        else
            	        {
            	        	while ( (stream_selectColumn->hasNext(stream_selectColumn))  ) {
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_selectColumn == NULL ? NULL : stream_selectColumn->nextTree(stream_selectColumn));

            	        	}
            	        	stream_selectColumn->reset(stream_selectColumn);

            	        }
            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleselectListEx; /* Prevent compiler warnings */
    ruleselectListEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_COMMA != NULL) stream_COMMA->free(stream_COMMA);
        if (stream_selectColumn != NULL) stream_selectColumn->free(stream_selectColumn);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end selectList */

/**
 * $ANTLR start selectColumn
 * SQL.g:39:1: selectColumn : ( selectItem | selectExpression );
 */
static SQLParser_selectColumn_return
selectColumn(pSQLParser ctx)
{
    SQLParser_selectColumn_return retval;


    pANTLR3_BASE_TREE root_0;

    SQLParser_selectItem_return selectItem14;
    #undef	RETURN_TYPE_selectItem14
    #define	RETURN_TYPE_selectItem14 SQLParser_selectItem_return

    SQLParser_selectExpression_return selectExpression15;
    #undef	RETURN_TYPE_selectExpression15
    #define	RETURN_TYPE_selectExpression15 SQLParser_selectExpression_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    selectItem14.tree = NULL;

    selectExpression15.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  SQL.g:40:2: ( selectItem | selectExpression )

            ANTLR3_UINT32 alt3;

            alt3=2;

            switch ( LA(1) )
            {
            case Identifier:
            	{
            		switch ( LA(2) )
            		{
            		case KW_AS:
            			{
            				alt3=1;
            			}
            		    break;
            		case LPAREN:
            			{
            				alt3=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 3;
            		    EXCEPTION->state        = 1;


            		    goto ruleselectColumnEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 3;
                EXCEPTION->state        = 0;


                goto ruleselectColumnEx;

            }

            switch (alt3)
            {
        	case 1:
        	    // SQL.g:40:4: selectItem
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_selectItem_in_selectColumn193);
        	        selectItem14=selectItem(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleselectColumnEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, selectItem14.tree);

        	    }
        	    break;
        	case 2:
        	    // SQL.g:41:4: selectExpression
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_selectExpression_in_selectColumn199);
        	        selectExpression15=selectExpression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleselectColumnEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, selectExpression15.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleselectColumnEx; /* Prevent compiler warnings */
    ruleselectColumnEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end selectColumn */

/**
 * $ANTLR start selectItem
 * SQL.g:44:1: selectItem : Identifier KW_AS Identifier -> ^( TOK_SELITEM Identifier Identifier ) ;
 */
static SQLParser_selectItem_return
selectItem(pSQLParser ctx)
{
    SQLParser_selectItem_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    Identifier16;
    pANTLR3_COMMON_TOKEN    KW_AS17;
    pANTLR3_COMMON_TOKEN    Identifier18;

    pANTLR3_BASE_TREE Identifier16_tree;
    pANTLR3_BASE_TREE KW_AS17_tree;
    pANTLR3_BASE_TREE Identifier18_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_AS;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_Identifier;

    /* Initialize rule variables
     */

    root_0 = NULL;

    Identifier16       = NULL;
    KW_AS17       = NULL;
    Identifier18       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    Identifier16_tree   = NULL;
    KW_AS17_tree   = NULL;
    Identifier18_tree   = NULL;

    stream_KW_AS   = NULL;
    #define CREATE_stream_KW_AS  if (stream_KW_AS == NULL) {stream_KW_AS = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_AS"); } 
    stream_Identifier   = NULL;
    #define CREATE_stream_Identifier  if (stream_Identifier == NULL) {stream_Identifier = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token Identifier"); } 

    retval.tree  = NULL;

    {
        // SQL.g:45:5: ( Identifier KW_AS Identifier -> ^( TOK_SELITEM Identifier Identifier ) )
        // SQL.g:45:7: Identifier KW_AS Identifier
        {
            Identifier16 = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_selectItem214);
            if  (HASEXCEPTION())
            {
                goto ruleselectItemEx;
            }
             
            CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, Identifier16, NULL);


            KW_AS17 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_AS, &FOLLOW_KW_AS_in_selectItem216);
            if  (HASEXCEPTION())
            {
                goto ruleselectItemEx;
            }
             
            CREATE_stream_KW_AS; stream_KW_AS->add(stream_KW_AS, KW_AS17, NULL);


            Identifier18 = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_selectItem218);
            if  (HASEXCEPTION())
            {
                goto ruleselectItemEx;
            }
             
            CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, Identifier18, NULL);


            /* AST REWRITE
             * elements          : Identifier, Identifier
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 46:6: -> ^( TOK_SELITEM Identifier Identifier )
            	{
            	    // SQL.g:46:9: ^( TOK_SELITEM Identifier Identifier )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TOK_SELITEM, (pANTLR3_UINT8)"TOK_SELITEM")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, 
            	        stream_Identifier == NULL ? NULL : stream_Identifier->nextNode(stream_Identifier)
            	        );

            	        ADAPTOR->addChild(ADAPTOR, root_1, 
            	        stream_Identifier == NULL ? NULL : stream_Identifier->nextNode(stream_Identifier)
            	        );

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleselectItemEx; /* Prevent compiler warnings */
    ruleselectItemEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_KW_AS != NULL) stream_KW_AS->free(stream_KW_AS);
        if (stream_Identifier != NULL) stream_Identifier->free(stream_Identifier);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end selectItem */

/**
 * $ANTLR start selectExpression
 * SQL.g:49:1: selectExpression : functionName= Identifier LPAREN itemName= Identifier RPAREN KW_AS asName= Identifier -> ^( TOK_SELEXPR $functionName $itemName $asName) ;
 */
static SQLParser_selectExpression_return
selectExpression(pSQLParser ctx)
{
    SQLParser_selectExpression_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    functionName;
    pANTLR3_COMMON_TOKEN    itemName;
    pANTLR3_COMMON_TOKEN    asName;
    pANTLR3_COMMON_TOKEN    LPAREN19;
    pANTLR3_COMMON_TOKEN    RPAREN20;
    pANTLR3_COMMON_TOKEN    KW_AS21;

    pANTLR3_BASE_TREE functionName_tree;
    pANTLR3_BASE_TREE itemName_tree;
    pANTLR3_BASE_TREE asName_tree;
    pANTLR3_BASE_TREE LPAREN19_tree;
    pANTLR3_BASE_TREE RPAREN20_tree;
    pANTLR3_BASE_TREE KW_AS21_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_AS;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_RPAREN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_Identifier;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_LPAREN;

    /* Initialize rule variables
     */

    root_0 = NULL;

    functionName       = NULL;
    itemName       = NULL;
    asName       = NULL;
    LPAREN19       = NULL;
    RPAREN20       = NULL;
    KW_AS21       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    functionName_tree   = NULL;
    itemName_tree   = NULL;
    asName_tree   = NULL;
    LPAREN19_tree   = NULL;
    RPAREN20_tree   = NULL;
    KW_AS21_tree   = NULL;

    stream_KW_AS   = NULL;
    #define CREATE_stream_KW_AS  if (stream_KW_AS == NULL) {stream_KW_AS = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_AS"); } 
    stream_RPAREN   = NULL;
    #define CREATE_stream_RPAREN  if (stream_RPAREN == NULL) {stream_RPAREN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token RPAREN"); } 
    stream_Identifier   = NULL;
    #define CREATE_stream_Identifier  if (stream_Identifier == NULL) {stream_Identifier = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token Identifier"); } 
    stream_LPAREN   = NULL;
    #define CREATE_stream_LPAREN  if (stream_LPAREN == NULL) {stream_LPAREN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token LPAREN"); } 

    retval.tree  = NULL;

    {
        // SQL.g:50:2: (functionName= Identifier LPAREN itemName= Identifier RPAREN KW_AS asName= Identifier -> ^( TOK_SELEXPR $functionName $itemName $asName) )
        // SQL.g:50:4: functionName= Identifier LPAREN itemName= Identifier RPAREN KW_AS asName= Identifier
        {
            functionName = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_selectExpression249);
            if  (HASEXCEPTION())
            {
                goto ruleselectExpressionEx;
            }
             
            CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, functionName, NULL);


            LPAREN19 = (pANTLR3_COMMON_TOKEN) MATCHT(LPAREN, &FOLLOW_LPAREN_in_selectExpression251);
            if  (HASEXCEPTION())
            {
                goto ruleselectExpressionEx;
            }
             
            CREATE_stream_LPAREN; stream_LPAREN->add(stream_LPAREN, LPAREN19, NULL);


            itemName = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_selectExpression255);
            if  (HASEXCEPTION())
            {
                goto ruleselectExpressionEx;
            }
             
            CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, itemName, NULL);


            RPAREN20 = (pANTLR3_COMMON_TOKEN) MATCHT(RPAREN, &FOLLOW_RPAREN_in_selectExpression257);
            if  (HASEXCEPTION())
            {
                goto ruleselectExpressionEx;
            }
             
            CREATE_stream_RPAREN; stream_RPAREN->add(stream_RPAREN, RPAREN20, NULL);


            KW_AS21 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_AS, &FOLLOW_KW_AS_in_selectExpression259);
            if  (HASEXCEPTION())
            {
                goto ruleselectExpressionEx;
            }
             
            CREATE_stream_KW_AS; stream_KW_AS->add(stream_KW_AS, KW_AS21, NULL);


            asName = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_selectExpression263);
            if  (HASEXCEPTION())
            {
                goto ruleselectExpressionEx;
            }
             
            CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, asName, NULL);


            /* AST REWRITE
             * elements          : itemName, asName, functionName
             * token labels      : itemName, asName, functionName
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_itemName;
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_asName;
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_functionName;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_itemName=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token itemName", itemName);
            	stream_asName=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token asName", asName);
            	stream_functionName=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token functionName", functionName);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 51:3: -> ^( TOK_SELEXPR $functionName $itemName $asName)
            	{
            	    // SQL.g:51:6: ^( TOK_SELEXPR $functionName $itemName $asName)
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TOK_SELEXPR, (pANTLR3_UINT8)"TOK_SELEXPR")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_functionName == NULL ? NULL : stream_functionName->nextNode(stream_functionName));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_itemName == NULL ? NULL : stream_itemName->nextNode(stream_itemName));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_asName == NULL ? NULL : stream_asName->nextNode(stream_asName));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_itemName != NULL) stream_itemName->free(stream_itemName); 
            	if (stream_asName != NULL) stream_asName->free(stream_asName); 
            	if (stream_functionName != NULL) stream_functionName->free(stream_functionName); 
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleselectExpressionEx; /* Prevent compiler warnings */
    ruleselectExpressionEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_KW_AS != NULL) stream_KW_AS->free(stream_KW_AS);
        if (stream_RPAREN != NULL) stream_RPAREN->free(stream_RPAREN);
        if (stream_Identifier != NULL) stream_Identifier->free(stream_Identifier);
        if (stream_LPAREN != NULL) stream_LPAREN->free(stream_LPAREN);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end selectExpression */

/**
 * $ANTLR start createStatement
 * SQL.g:54:1: createStatement : ( KW_CREATE KW_SCHEMA Identifier schemaList -> ^( TOK_CREATE_SCHEMA Identifier schemaList ) | KW_CREATE streamType KW_STREAM streamName= Identifier schemaName= Identifier -> ^( TOK_CREATE_STREAM streamType $streamName $schemaName) | KW_CREATE KW_WINDOW windowName= Identifier LPAREN KW_SIZE Number KW_ADVANCE Number KW_ON onWhat= Identifier RPAREN -> ^( TOK_CREATE_WINDOW $windowName Number Number $onWhat) );
 */
static SQLParser_createStatement_return
createStatement(pSQLParser ctx)
{
    SQLParser_createStatement_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    streamName;
    pANTLR3_COMMON_TOKEN    schemaName;
    pANTLR3_COMMON_TOKEN    windowName;
    pANTLR3_COMMON_TOKEN    onWhat;
    pANTLR3_COMMON_TOKEN    KW_CREATE22;
    pANTLR3_COMMON_TOKEN    KW_SCHEMA23;
    pANTLR3_COMMON_TOKEN    Identifier24;
    pANTLR3_COMMON_TOKEN    KW_CREATE26;
    pANTLR3_COMMON_TOKEN    KW_STREAM28;
    pANTLR3_COMMON_TOKEN    KW_CREATE29;
    pANTLR3_COMMON_TOKEN    KW_WINDOW30;
    pANTLR3_COMMON_TOKEN    LPAREN31;
    pANTLR3_COMMON_TOKEN    KW_SIZE32;
    pANTLR3_COMMON_TOKEN    Number33;
    pANTLR3_COMMON_TOKEN    KW_ADVANCE34;
    pANTLR3_COMMON_TOKEN    Number35;
    pANTLR3_COMMON_TOKEN    KW_ON36;
    pANTLR3_COMMON_TOKEN    RPAREN37;
    SQLParser_schemaList_return schemaList25;
    #undef	RETURN_TYPE_schemaList25
    #define	RETURN_TYPE_schemaList25 SQLParser_schemaList_return

    SQLParser_streamType_return streamType27;
    #undef	RETURN_TYPE_streamType27
    #define	RETURN_TYPE_streamType27 SQLParser_streamType_return

    pANTLR3_BASE_TREE streamName_tree;
    pANTLR3_BASE_TREE schemaName_tree;
    pANTLR3_BASE_TREE windowName_tree;
    pANTLR3_BASE_TREE onWhat_tree;
    pANTLR3_BASE_TREE KW_CREATE22_tree;
    pANTLR3_BASE_TREE KW_SCHEMA23_tree;
    pANTLR3_BASE_TREE Identifier24_tree;
    pANTLR3_BASE_TREE KW_CREATE26_tree;
    pANTLR3_BASE_TREE KW_STREAM28_tree;
    pANTLR3_BASE_TREE KW_CREATE29_tree;
    pANTLR3_BASE_TREE KW_WINDOW30_tree;
    pANTLR3_BASE_TREE LPAREN31_tree;
    pANTLR3_BASE_TREE KW_SIZE32_tree;
    pANTLR3_BASE_TREE Number33_tree;
    pANTLR3_BASE_TREE KW_ADVANCE34_tree;
    pANTLR3_BASE_TREE Number35_tree;
    pANTLR3_BASE_TREE KW_ON36_tree;
    pANTLR3_BASE_TREE RPAREN37_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_SCHEMA;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_RPAREN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_CREATE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_Number;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_ADVANCE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_WINDOW;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_SIZE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_STREAM;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_Identifier;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_LPAREN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_KW_ON;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_streamType;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_schemaList;
    /* Initialize rule variables
     */

    root_0 = NULL;

    streamName       = NULL;
    schemaName       = NULL;
    windowName       = NULL;
    onWhat       = NULL;
    KW_CREATE22       = NULL;
    KW_SCHEMA23       = NULL;
    Identifier24       = NULL;
    KW_CREATE26       = NULL;
    KW_STREAM28       = NULL;
    KW_CREATE29       = NULL;
    KW_WINDOW30       = NULL;
    LPAREN31       = NULL;
    KW_SIZE32       = NULL;
    Number33       = NULL;
    KW_ADVANCE34       = NULL;
    Number35       = NULL;
    KW_ON36       = NULL;
    RPAREN37       = NULL;
    schemaList25.tree = NULL;

    streamType27.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    streamName_tree   = NULL;
    schemaName_tree   = NULL;
    windowName_tree   = NULL;
    onWhat_tree   = NULL;
    KW_CREATE22_tree   = NULL;
    KW_SCHEMA23_tree   = NULL;
    Identifier24_tree   = NULL;
    KW_CREATE26_tree   = NULL;
    KW_STREAM28_tree   = NULL;
    KW_CREATE29_tree   = NULL;
    KW_WINDOW30_tree   = NULL;
    LPAREN31_tree   = NULL;
    KW_SIZE32_tree   = NULL;
    Number33_tree   = NULL;
    KW_ADVANCE34_tree   = NULL;
    Number35_tree   = NULL;
    KW_ON36_tree   = NULL;
    RPAREN37_tree   = NULL;

    stream_KW_SCHEMA   = NULL;
    #define CREATE_stream_KW_SCHEMA  if (stream_KW_SCHEMA == NULL) {stream_KW_SCHEMA = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_SCHEMA"); } 
    stream_RPAREN   = NULL;
    #define CREATE_stream_RPAREN  if (stream_RPAREN == NULL) {stream_RPAREN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token RPAREN"); } 
    stream_KW_CREATE   = NULL;
    #define CREATE_stream_KW_CREATE  if (stream_KW_CREATE == NULL) {stream_KW_CREATE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_CREATE"); } 
    stream_Number   = NULL;
    #define CREATE_stream_Number  if (stream_Number == NULL) {stream_Number = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token Number"); } 
    stream_KW_ADVANCE   = NULL;
    #define CREATE_stream_KW_ADVANCE  if (stream_KW_ADVANCE == NULL) {stream_KW_ADVANCE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_ADVANCE"); } 
    stream_KW_WINDOW   = NULL;
    #define CREATE_stream_KW_WINDOW  if (stream_KW_WINDOW == NULL) {stream_KW_WINDOW = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_WINDOW"); } 
    stream_KW_SIZE   = NULL;
    #define CREATE_stream_KW_SIZE  if (stream_KW_SIZE == NULL) {stream_KW_SIZE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_SIZE"); } 
    stream_KW_STREAM   = NULL;
    #define CREATE_stream_KW_STREAM  if (stream_KW_STREAM == NULL) {stream_KW_STREAM = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_STREAM"); } 
    stream_Identifier   = NULL;
    #define CREATE_stream_Identifier  if (stream_Identifier == NULL) {stream_Identifier = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token Identifier"); } 
    stream_LPAREN   = NULL;
    #define CREATE_stream_LPAREN  if (stream_LPAREN == NULL) {stream_LPAREN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token LPAREN"); } 
    stream_KW_ON   = NULL;
    #define CREATE_stream_KW_ON  if (stream_KW_ON == NULL) {stream_KW_ON = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token KW_ON"); } 
    stream_streamType   = NULL;
    #define CREATE_stream_streamType  if (stream_streamType == NULL) {stream_streamType = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule streamType"); }
    stream_schemaList   = NULL;
    #define CREATE_stream_schemaList  if (stream_schemaList == NULL) {stream_schemaList = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule schemaList"); }

    retval.tree  = NULL;

    {
        {
            //  SQL.g:55:2: ( KW_CREATE KW_SCHEMA Identifier schemaList -> ^( TOK_CREATE_SCHEMA Identifier schemaList ) | KW_CREATE streamType KW_STREAM streamName= Identifier schemaName= Identifier -> ^( TOK_CREATE_STREAM streamType $streamName $schemaName) | KW_CREATE KW_WINDOW windowName= Identifier LPAREN KW_SIZE Number KW_ADVANCE Number KW_ON onWhat= Identifier RPAREN -> ^( TOK_CREATE_WINDOW $windowName Number Number $onWhat) )

            ANTLR3_UINT32 alt4;

            alt4=3;

            switch ( LA(1) )
            {
            case KW_CREATE:
            	{
            		switch ( LA(2) )
            		{
            		case KW_SCHEMA:
            			{
            				alt4=1;
            			}
            		    break;
            		case KW_WINDOW:
            			{
            				alt4=3;
            			}
            		    break;
            		case KW_INPUT:
            		case KW_OUTPUT:
            			{
            				alt4=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 4;
            		    EXCEPTION->state        = 1;


            		    goto rulecreateStatementEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 4;
                EXCEPTION->state        = 0;


                goto rulecreateStatementEx;

            }

            switch (alt4)
            {
        	case 1:
        	    // SQL.g:55:4: KW_CREATE KW_SCHEMA Identifier schemaList
        	    {
        	        KW_CREATE22 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_CREATE, &FOLLOW_KW_CREATE_in_createStatement291);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_KW_CREATE; stream_KW_CREATE->add(stream_KW_CREATE, KW_CREATE22, NULL);


        	        KW_SCHEMA23 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_SCHEMA, &FOLLOW_KW_SCHEMA_in_createStatement293);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_KW_SCHEMA; stream_KW_SCHEMA->add(stream_KW_SCHEMA, KW_SCHEMA23, NULL);


        	        Identifier24 = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_createStatement295);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, Identifier24, NULL);


        	        FOLLOWPUSH(FOLLOW_schemaList_in_createStatement297);
        	        schemaList25=schemaList(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }

        	        CREATE_stream_schemaList; stream_schemaList->add(stream_schemaList, schemaList25.tree, NULL);

        	        /* AST REWRITE
        	         * elements          : schemaList, Identifier
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 56:3: -> ^( TOK_CREATE_SCHEMA Identifier schemaList )
        	        	{
        	        	    // SQL.g:56:6: ^( TOK_CREATE_SCHEMA Identifier schemaList )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TOK_CREATE_SCHEMA, (pANTLR3_UINT8)"TOK_CREATE_SCHEMA")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, 
        	        	        stream_Identifier == NULL ? NULL : stream_Identifier->nextNode(stream_Identifier)
        	        	        );

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_schemaList == NULL ? NULL : stream_schemaList->nextTree(stream_schemaList));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 2:
        	    // SQL.g:57:4: KW_CREATE streamType KW_STREAM streamName= Identifier schemaName= Identifier
        	    {
        	        KW_CREATE26 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_CREATE, &FOLLOW_KW_CREATE_in_createStatement316);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_KW_CREATE; stream_KW_CREATE->add(stream_KW_CREATE, KW_CREATE26, NULL);


        	        FOLLOWPUSH(FOLLOW_streamType_in_createStatement318);
        	        streamType27=streamType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }

        	        CREATE_stream_streamType; stream_streamType->add(stream_streamType, streamType27.tree, NULL);

        	        KW_STREAM28 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_STREAM, &FOLLOW_KW_STREAM_in_createStatement320);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_KW_STREAM; stream_KW_STREAM->add(stream_KW_STREAM, KW_STREAM28, NULL);


        	        streamName = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_createStatement324);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, streamName, NULL);


        	        schemaName = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_createStatement328);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, schemaName, NULL);


        	        /* AST REWRITE
        	         * elements          : streamType, schemaName, streamName
        	         * token labels      : schemaName, streamName
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_schemaName;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_streamName;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_schemaName=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token schemaName", schemaName);
        	        	stream_streamName=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token streamName", streamName);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 58:3: -> ^( TOK_CREATE_STREAM streamType $streamName $schemaName)
        	        	{
        	        	    // SQL.g:58:6: ^( TOK_CREATE_STREAM streamType $streamName $schemaName)
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TOK_CREATE_STREAM, (pANTLR3_UINT8)"TOK_CREATE_STREAM")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_streamType == NULL ? NULL : stream_streamType->nextTree(stream_streamType));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_streamName == NULL ? NULL : stream_streamName->nextNode(stream_streamName));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_schemaName == NULL ? NULL : stream_schemaName->nextNode(stream_schemaName));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_schemaName != NULL) stream_schemaName->free(stream_schemaName); 
        	        	if (stream_streamName != NULL) stream_streamName->free(stream_streamName); 
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 3:
        	    // SQL.g:59:4: KW_CREATE KW_WINDOW windowName= Identifier LPAREN KW_SIZE Number KW_ADVANCE Number KW_ON onWhat= Identifier RPAREN
        	    {
        	        KW_CREATE29 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_CREATE, &FOLLOW_KW_CREATE_in_createStatement349);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_KW_CREATE; stream_KW_CREATE->add(stream_KW_CREATE, KW_CREATE29, NULL);


        	        KW_WINDOW30 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_WINDOW, &FOLLOW_KW_WINDOW_in_createStatement351);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_KW_WINDOW; stream_KW_WINDOW->add(stream_KW_WINDOW, KW_WINDOW30, NULL);


        	        windowName = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_createStatement358);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, windowName, NULL);


        	        LPAREN31 = (pANTLR3_COMMON_TOKEN) MATCHT(LPAREN, &FOLLOW_LPAREN_in_createStatement360);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_LPAREN; stream_LPAREN->add(stream_LPAREN, LPAREN31, NULL);


        	        KW_SIZE32 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_SIZE, &FOLLOW_KW_SIZE_in_createStatement362);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_KW_SIZE; stream_KW_SIZE->add(stream_KW_SIZE, KW_SIZE32, NULL);


        	        Number33 = (pANTLR3_COMMON_TOKEN) MATCHT(Number, &FOLLOW_Number_in_createStatement364);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_Number; stream_Number->add(stream_Number, Number33, NULL);


        	        KW_ADVANCE34 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_ADVANCE, &FOLLOW_KW_ADVANCE_in_createStatement366);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_KW_ADVANCE; stream_KW_ADVANCE->add(stream_KW_ADVANCE, KW_ADVANCE34, NULL);


        	        Number35 = (pANTLR3_COMMON_TOKEN) MATCHT(Number, &FOLLOW_Number_in_createStatement368);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_Number; stream_Number->add(stream_Number, Number35, NULL);


        	        KW_ON36 = (pANTLR3_COMMON_TOKEN) MATCHT(KW_ON, &FOLLOW_KW_ON_in_createStatement370);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_KW_ON; stream_KW_ON->add(stream_KW_ON, KW_ON36, NULL);


        	        onWhat = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_createStatement374);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, onWhat, NULL);


        	        RPAREN37 = (pANTLR3_COMMON_TOKEN) MATCHT(RPAREN, &FOLLOW_RPAREN_in_createStatement376);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecreateStatementEx;
        	        }
        	         
        	        CREATE_stream_RPAREN; stream_RPAREN->add(stream_RPAREN, RPAREN37, NULL);


        	        /* AST REWRITE
        	         * elements          : Number, Number, onWhat, windowName
        	         * token labels      : windowName, onWhat
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_windowName;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_onWhat;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_windowName=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token windowName", windowName);
        	        	stream_onWhat=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token onWhat", onWhat);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 61:3: -> ^( TOK_CREATE_WINDOW $windowName Number Number $onWhat)
        	        	{
        	        	    // SQL.g:61:6: ^( TOK_CREATE_WINDOW $windowName Number Number $onWhat)
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TOK_CREATE_WINDOW, (pANTLR3_UINT8)"TOK_CREATE_WINDOW")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_windowName == NULL ? NULL : stream_windowName->nextNode(stream_windowName));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, 
        	        	        stream_Number == NULL ? NULL : stream_Number->nextNode(stream_Number)
        	        	        );

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, 
        	        	        stream_Number == NULL ? NULL : stream_Number->nextNode(stream_Number)
        	        	        );

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_onWhat == NULL ? NULL : stream_onWhat->nextNode(stream_onWhat));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_windowName != NULL) stream_windowName->free(stream_windowName); 
        	        	if (stream_onWhat != NULL) stream_onWhat->free(stream_onWhat); 
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulecreateStatementEx; /* Prevent compiler warnings */
    rulecreateStatementEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_KW_SCHEMA != NULL) stream_KW_SCHEMA->free(stream_KW_SCHEMA);
        if (stream_RPAREN != NULL) stream_RPAREN->free(stream_RPAREN);
        if (stream_KW_CREATE != NULL) stream_KW_CREATE->free(stream_KW_CREATE);
        if (stream_Number != NULL) stream_Number->free(stream_Number);
        if (stream_KW_ADVANCE != NULL) stream_KW_ADVANCE->free(stream_KW_ADVANCE);
        if (stream_KW_WINDOW != NULL) stream_KW_WINDOW->free(stream_KW_WINDOW);
        if (stream_KW_SIZE != NULL) stream_KW_SIZE->free(stream_KW_SIZE);
        if (stream_KW_STREAM != NULL) stream_KW_STREAM->free(stream_KW_STREAM);
        if (stream_Identifier != NULL) stream_Identifier->free(stream_Identifier);
        if (stream_LPAREN != NULL) stream_LPAREN->free(stream_LPAREN);
        if (stream_KW_ON != NULL) stream_KW_ON->free(stream_KW_ON);
        if (stream_streamType != NULL) stream_streamType->free(stream_streamType);
        if (stream_schemaList != NULL) stream_schemaList->free(stream_schemaList);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end createStatement */

/**
 * $ANTLR start schemaList
 * SQL.g:64:1: schemaList : LPAREN columnNameType ( COMMA columnNameType )* RPAREN -> ^( TOK_SCHEMA_LIST ( columnNameType )+ ) ;
 */
static SQLParser_schemaList_return
schemaList(pSQLParser ctx)
{
    SQLParser_schemaList_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    LPAREN38;
    pANTLR3_COMMON_TOKEN    COMMA40;
    pANTLR3_COMMON_TOKEN    RPAREN42;
    SQLParser_columnNameType_return columnNameType39;
    #undef	RETURN_TYPE_columnNameType39
    #define	RETURN_TYPE_columnNameType39 SQLParser_columnNameType_return

    SQLParser_columnNameType_return columnNameType41;
    #undef	RETURN_TYPE_columnNameType41
    #define	RETURN_TYPE_columnNameType41 SQLParser_columnNameType_return

    pANTLR3_BASE_TREE LPAREN38_tree;
    pANTLR3_BASE_TREE COMMA40_tree;
    pANTLR3_BASE_TREE RPAREN42_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_RPAREN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_COMMA;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_LPAREN;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_columnNameType;
    /* Initialize rule variables
     */

    root_0 = NULL;

    LPAREN38       = NULL;
    COMMA40       = NULL;
    RPAREN42       = NULL;
    columnNameType39.tree = NULL;

    columnNameType41.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    LPAREN38_tree   = NULL;
    COMMA40_tree   = NULL;
    RPAREN42_tree   = NULL;

    stream_RPAREN   = NULL;
    #define CREATE_stream_RPAREN  if (stream_RPAREN == NULL) {stream_RPAREN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token RPAREN"); } 
    stream_COMMA   = NULL;
    #define CREATE_stream_COMMA  if (stream_COMMA == NULL) {stream_COMMA = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token COMMA"); } 
    stream_LPAREN   = NULL;
    #define CREATE_stream_LPAREN  if (stream_LPAREN == NULL) {stream_LPAREN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token LPAREN"); } 
    stream_columnNameType   = NULL;
    #define CREATE_stream_columnNameType  if (stream_columnNameType == NULL) {stream_columnNameType = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule columnNameType"); }

    retval.tree  = NULL;

    {
        // SQL.g:65:2: ( LPAREN columnNameType ( COMMA columnNameType )* RPAREN -> ^( TOK_SCHEMA_LIST ( columnNameType )+ ) )
        // SQL.g:65:4: LPAREN columnNameType ( COMMA columnNameType )* RPAREN
        {
            LPAREN38 = (pANTLR3_COMMON_TOKEN) MATCHT(LPAREN, &FOLLOW_LPAREN_in_schemaList405);
            if  (HASEXCEPTION())
            {
                goto ruleschemaListEx;
            }
             
            CREATE_stream_LPAREN; stream_LPAREN->add(stream_LPAREN, LPAREN38, NULL);


            FOLLOWPUSH(FOLLOW_columnNameType_in_schemaList407);
            columnNameType39=columnNameType(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleschemaListEx;
            }

            CREATE_stream_columnNameType; stream_columnNameType->add(stream_columnNameType, columnNameType39.tree, NULL);

            // SQL.g:65:26: ( COMMA columnNameType )*

            for (;;)
            {
                int alt5=2;
                switch ( LA(1) )
                {
                case COMMA:
                	{
                		alt5=1;
                	}
                    break;

                }

                switch (alt5)
                {
            	case 1:
            	    // SQL.g:65:27: COMMA columnNameType
            	    {
            	        COMMA40 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_schemaList410);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleschemaListEx;
            	        }
            	         
            	        CREATE_stream_COMMA; stream_COMMA->add(stream_COMMA, COMMA40, NULL);


            	        FOLLOWPUSH(FOLLOW_columnNameType_in_schemaList412);
            	        columnNameType41=columnNameType(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleschemaListEx;
            	        }

            	        CREATE_stream_columnNameType; stream_columnNameType->add(stream_columnNameType, columnNameType41.tree, NULL);

            	    }
            	    break;

            	default:
            	    goto loop5;	/* break out of the loop */
            	    break;
                }
            }
            loop5: ; /* Jump out to here if this rule does not match */


            RPAREN42 = (pANTLR3_COMMON_TOKEN) MATCHT(RPAREN, &FOLLOW_RPAREN_in_schemaList416);
            if  (HASEXCEPTION())
            {
                goto ruleschemaListEx;
            }
             
            CREATE_stream_RPAREN; stream_RPAREN->add(stream_RPAREN, RPAREN42, NULL);


            /* AST REWRITE
             * elements          : columnNameType
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 66:3: -> ^( TOK_SCHEMA_LIST ( columnNameType )+ )
            	{
            	    // SQL.g:66:6: ^( TOK_SCHEMA_LIST ( columnNameType )+ )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TOK_SCHEMA_LIST, (pANTLR3_UINT8)"TOK_SCHEMA_LIST")
            	        , root_1));

            	        if ((stream_columnNameType == NULL || !stream_columnNameType->hasNext(stream_columnNameType))  )
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_REWRITE_EARLY_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_REWRITE_EARLY_EXCEPTION_NAME;
            	        }
            	        else
            	        {
            	        	while ( (stream_columnNameType->hasNext(stream_columnNameType))  ) {
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_columnNameType == NULL ? NULL : stream_columnNameType->nextTree(stream_columnNameType));

            	        	}
            	        	stream_columnNameType->reset(stream_columnNameType);

            	        }
            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleschemaListEx; /* Prevent compiler warnings */
    ruleschemaListEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_RPAREN != NULL) stream_RPAREN->free(stream_RPAREN);
        if (stream_COMMA != NULL) stream_COMMA->free(stream_COMMA);
        if (stream_LPAREN != NULL) stream_LPAREN->free(stream_LPAREN);
        if (stream_columnNameType != NULL) stream_columnNameType->free(stream_columnNameType);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end schemaList */

/**
 * $ANTLR start streamType
 * SQL.g:69:1: streamType : ( KW_INPUT | KW_OUTPUT ) ;
 */
static SQLParser_streamType_return
streamType(pSQLParser ctx)
{
    SQLParser_streamType_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set43;

    pANTLR3_BASE_TREE set43_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set43       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set43_tree   = NULL;


    retval.tree  = NULL;

    {
        // SQL.g:70:2: ( ( KW_INPUT | KW_OUTPUT ) )
        // SQL.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            set43=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( LA(1) == KW_INPUT || LA(1) == KW_OUTPUT )
            {
                CONSUME();
                ADAPTOR->addChild(ADAPTOR, root_0, 
                (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set43))
                );
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulestreamTypeEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulestreamTypeEx; /* Prevent compiler warnings */
    rulestreamTypeEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end streamType */

/**
 * $ANTLR start columnNameType
 * SQL.g:73:1: columnNameType : coluName= Identifier dataType -> ^( TOK_NAME_TYPE $coluName dataType ) ;
 */
static SQLParser_columnNameType_return
columnNameType(pSQLParser ctx)
{
    SQLParser_columnNameType_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    coluName;
    SQLParser_dataType_return dataType44;
    #undef	RETURN_TYPE_dataType44
    #define	RETURN_TYPE_dataType44 SQLParser_dataType_return

    pANTLR3_BASE_TREE coluName_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_Identifier;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_dataType;
    /* Initialize rule variables
     */

    root_0 = NULL;

    coluName       = NULL;
    dataType44.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    coluName_tree   = NULL;

    stream_Identifier   = NULL;
    #define CREATE_stream_Identifier  if (stream_Identifier == NULL) {stream_Identifier = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token Identifier"); } 
    stream_dataType   = NULL;
    #define CREATE_stream_dataType  if (stream_dataType == NULL) {stream_dataType = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule dataType"); }

    retval.tree  = NULL;

    {
        // SQL.g:74:2: (coluName= Identifier dataType -> ^( TOK_NAME_TYPE $coluName dataType ) )
        // SQL.g:74:4: coluName= Identifier dataType
        {
            coluName = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_columnNameType458);
            if  (HASEXCEPTION())
            {
                goto rulecolumnNameTypeEx;
            }
             
            CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, coluName, NULL);


            FOLLOWPUSH(FOLLOW_dataType_in_columnNameType460);
            dataType44=dataType(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecolumnNameTypeEx;
            }

            CREATE_stream_dataType; stream_dataType->add(stream_dataType, dataType44.tree, NULL);

            /* AST REWRITE
             * elements          : dataType, coluName
             * token labels      : coluName
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_coluName;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_coluName=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token coluName", coluName);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 75:3: -> ^( TOK_NAME_TYPE $coluName dataType )
            	{
            	    // SQL.g:75:6: ^( TOK_NAME_TYPE $coluName dataType )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TOK_NAME_TYPE, (pANTLR3_UINT8)"TOK_NAME_TYPE")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_coluName == NULL ? NULL : stream_coluName->nextNode(stream_coluName));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_dataType == NULL ? NULL : stream_dataType->nextTree(stream_dataType));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_coluName != NULL) stream_coluName->free(stream_coluName); 
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto rulecolumnNameTypeEx; /* Prevent compiler warnings */
    rulecolumnNameTypeEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_Identifier != NULL) stream_Identifier->free(stream_Identifier);
        if (stream_dataType != NULL) stream_dataType->free(stream_dataType);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end columnNameType */

/**
 * $ANTLR start dataType
 * SQL.g:78:1: dataType : ( KW_INT | KW_DOUBLE );
 */
static SQLParser_dataType_return
dataType(pSQLParser ctx)
{
    SQLParser_dataType_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set45;

    pANTLR3_BASE_TREE set45_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set45       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set45_tree   = NULL;


    retval.tree  = NULL;

    {
        // SQL.g:79:2: ( KW_INT | KW_DOUBLE )
        // SQL.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            set45=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( LA(1) == KW_DOUBLE || LA(1) == KW_INT )
            {
                CONSUME();
                ADAPTOR->addChild(ADAPTOR, root_0, 
                (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set45))
                );
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruledataTypeEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledataTypeEx; /* Prevent compiler warnings */
    ruledataTypeEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end dataType */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
